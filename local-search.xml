<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端面试基础知识总结（八）：算法与数据结构</title>
    <link href="/2024/03/16/front-end-interview-preparation-7/"/>
    <url>/2024/03/16/front-end-interview-preparation-7/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。散列表、栈、队列、堆、树、图等等各种数据结构都是在链表或者数组上的特殊操作。Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。</p><p>数组：紧凑连续存储。</p><ul><li>优点：1. 随机访问，查询快 2. 更节约存储空间</li><li>缺点：1. 数组扩容麻烦 2. 插入和删除操作麻烦</li></ul><p>链表：元素不连续，而是靠指针指向下一个元素的位置</p><ul><li>优点：1，数组扩容简单 2. 插入和删除操作简单</li><li>缺点：1. 不能随机访问，查询慢 2. 消耗相对更多的储存空间，要存储前驱&#x2F;后驱指针。</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>一个对象存储这个本身的值和下一个元素的地址:</p><p><img src="/img/front-end-interview-preparation/DSA-linkedlist.jpg" alt="链表"></p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val, next</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val === <span class="hljs-literal">undefined</span> ? <span class="hljs-number">0</span> : val;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : next;<br>&#125;<br></code></pre></td></tr></table></figure><p>链表在开发中也是经常用到的数据结构，React16 的 Fiber Node 连接起来形成的 Fiber Tree, 就是个单链表结构。</p><ul><li>基本问题：打印、删除、反转链表</li><li>环类问题：单指针是否存在循环结构</li><li>快慢指针<ul><li>输出链表中倒数第k个结点</li><li>两个链表的公共节点</li></ul></li><li>哑节点（dummy）</li><li>双向链表（还有 prev 字段）</li></ul><h3 id="打印链表"><a href="#打印链表" class="headerlink" title="打印链表"></a>打印链表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printHeadToTail</span>(<span class="hljs-params">head</span>)<br>&#123;<br>    <span class="hljs-keyword">const</span> array = [];<br>    <span class="hljs-keyword">while</span>(head)&#123;<br>        array.<span class="hljs-title function_">push</span>(head.<span class="hljs-property">val</span>);<br>        head = head.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><a href="https://leetcode.com/problems/reverse-linked-list/">leetcode #206</a></p><p>迭代：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> reverseList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> curr = head;<br>    <span class="hljs-keyword">while</span>(curr !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 1. 记录下一个节点</span><br>        <span class="hljs-keyword">const</span> next = curr.<span class="hljs-property">next</span>;<br>        <span class="hljs-comment">// 2. 反转链表指针</span><br>        curr.<span class="hljs-property">next</span> = prev;<br>        <span class="hljs-comment">// 3. 指针向前走</span><br>        prev = curr;<br>        curr = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;;<br></code></pre></td></tr></table></figure><p>递归：</p><p><img src="/img/front-end-interview-preparation/DSA-reverse-linkedList.png" alt="反转链表（递归做法）"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reverseList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// 1. 递归记录下尾节点</span><br>    <span class="hljs-keyword">const</span> newHead = <span class="hljs-title function_">reverseList</span>(head.<span class="hljs-property">next</span>);<br>    <span class="hljs-comment">// 2. 反转链表指针</span><br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 3. 返回尾节点</span><br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h3><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/">leetcode #21</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 迭代</span><br><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span> (<span class="hljs-params">l1, l2</span>) &#123;<br>    <span class="hljs-keyword">let</span> p1 = list1;<br>    <span class="hljs-keyword">let</span> p2 = list2;<br>    <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-literal">null</span>);<br>    p = dummy;<br><br>    <span class="hljs-keyword">while</span>(p1 &amp;&amp; p2) &#123;<br>        <span class="hljs-keyword">if</span>(p1.<span class="hljs-property">val</span> &gt;= p2.<span class="hljs-property">val</span>) &#123;<br>            p.<span class="hljs-property">next</span> = p2;<br>            p2 = p2.<span class="hljs-property">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.<span class="hljs-property">next</span> = p1;<br>            p1 = p1.<span class="hljs-property">next</span>;<br>        &#125;<br>        p = p.<span class="hljs-property">next</span>;<br>        p.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p2) &#123;<br>        p.<span class="hljs-property">next</span> = p2;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p1) &#123;<br>        p.<span class="hljs-property">next</span> = p1;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>&#125;;<br><br><span class="hljs-comment">// 递归</span><br><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) &#123;<br>  <span class="hljs-keyword">if</span> (l1 === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> l2;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> l1;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.<span class="hljs-property">val</span> &lt; l2.<span class="hljs-property">val</span>) &#123;<br>      l1.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeTwoLists</span>(l1.<span class="hljs-property">next</span>, l2);<br>      <span class="hljs-keyword">return</span> l1;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      l2.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeTwoLists</span>(l1, l2.<span class="hljs-property">next</span>);<br>      <span class="hljs-keyword">return</span> l2;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><a href="https://leetcode.com/problems/linked-list-cycle/description/">leetcode #141</a></p><p>判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：</p><p>每当慢指针 slow 前进一步，快指针 fast 就前进两步。</p><p>如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> hasCycle = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">var</span> slow = head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-property">next</span> != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.<span class="hljs-property">next</span>;<br>        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h3><p>两个链表是否相交: 拼接两个链表</p><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/">leetcode #160</a></p><p><img src="/img/front-end-interview-preparation/DSA-linkedlist-intersection.png" alt="例子"></p><p><img src="/img/front-end-interview-preparation/DSA-linkedlist-intersection-solution.png" alt="解法"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) &#123;<br>    <span class="hljs-keyword">var</span> p1 = headA, p2 = headB;<br>    <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span>) p1 = headB;<br>        <span class="hljs-keyword">else</span>            p1 = p1.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">null</span>) p2 = headA;<br>        <span class="hljs-keyword">else</span>            p2 = p2.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是我们在开发中最常见到的数据结构了，用于按顺序存储元素的集合。但是元素可以随机存取，因为数组中的每个元素都可以通过数组索引来识别。插入和删除时要移动后续元素，还要考虑扩容问题，插入慢。</p><p>双指针技巧</p><ul><li>快慢指针：两个指针同向而行，一快一慢<ul><li>删除有序数组重复项 #26</li></ul></li><li>左右指针：两个指针相向而行或者相背而行（从中间向两端扩散）<ul><li>指针相向：回文串判断</li><li>相背而行：最长回文串 #5</li></ul></li></ul><p>N数之和</p><ul><li>两数之和 #1</li><li>三数之和</li><li>N数之和</li></ul><p>辅助数组技巧</p><ul><li>前缀和数组：适用于原始数组不会被修改时，频繁查询某个区间的累加和 #303 #304</li><li>差分数组：适用于频繁对原始数组的某个区间元素进行增减 #370 #1094</li></ul><h3 id="快慢指针技巧"><a href="#快慢指针技巧" class="headerlink" title="快慢指针技巧"></a>快慢指针技巧</h3><p>删除有序数组重复项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (fast &lt; nums.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] !== nums[slow]) &#123;<br>            slow++;<br>            nums[slow] = nums[fast];<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="左右指针技巧"><a href="#左右指针技巧" class="headerlink" title="左右指针技巧"></a>左右指针技巧</h3><p>最长回文子串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">getPalindrome</span> = (<span class="hljs-params">left, right</span>) =&gt; &#123;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-property">length</span> &amp;&amp; s[left] == s[right]) &#123;<br>            left--;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substring</span>(left + <span class="hljs-number">1</span>, right);<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">const</span> s1 = <span class="hljs-title function_">getPalindrome</span>(i, i);<br>        <span class="hljs-keyword">const</span> s2 = <span class="hljs-title function_">getPalindrome</span>(i, i+<span class="hljs-number">1</span>);<br>        result = s1.<span class="hljs-property">length</span> &gt; result.<span class="hljs-property">length</span> ? s1 : result;<br>        result = s2.<span class="hljs-property">length</span> &gt; result.<span class="hljs-property">length</span> ? s2 : result;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>求指针：One-Pass Hash Table</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map[target - nums[i]] !== <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">return</span> [map[target - nums[i]], i];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map[nums[i]] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [];<br>&#125;;<br></code></pre></td></tr></table></figure><p>求数字：先排序，后双指针</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">let</span> p1 = <span class="hljs-number">0</span>, p2 = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;<br>        <span class="hljs-keyword">let</span> sum = nums[p1] + nums[p2];<br>        <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            p1++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>            p2--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum === target) &#123;<br>            <span class="hljs-keyword">return</span> [nums[p1], nums[p2]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="前缀和数组"><a href="#前缀和数组" class="headerlink" title="前缀和数组"></a>前缀和数组</h3><p>前缀和数组适用于原始数组不会被修改时，频繁<strong>查询某个区间的累加和</strong></p><p>#303. Range Sum Query - Immutable</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">NumArray</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nums</span> = nums;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">preSum</span> = nums.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">1</span> ? [nums[<span class="hljs-number">0</span>]] : [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">preSum</span>[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">preSum</span>[i - <span class="hljs-number">1</span>] + nums[i];<br>    &#125;<br>&#125;;<br><br><span class="hljs-title class_">NumArray</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sumRange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">left, right</span>) &#123;<br>    <span class="hljs-keyword">const</span> leftSum = left &gt;= <span class="hljs-number">1</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">preSum</span>[left - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">preSum</span>[right] - leftSum;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h3><p>差分数组适用于频繁对原始数组的<strong>某个区间元素进行增减</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Difference</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-comment">// 差分数组</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span> = [];<br><br>    <span class="hljs-comment">/* 输入一个初始数组，区间操作将在这个数组上进行 */</span><br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(nums.<span class="hljs-property">length</span>);<br>        <span class="hljs-comment">// 根据初始数组构造差分数组</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span>[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span>[i] = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/* 给闭区间 [i, j] 增加 val（可以是负数）*/</span><br><span class="hljs-title class_">Difference</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">increment</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">i, j, val</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span>[i] += val;<br>    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span>.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span>[j + <span class="hljs-number">1</span>] -= val;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/* 返回结果数组 */</span><br><span class="hljs-title class_">Difference</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">result</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span>.<span class="hljs-property">length</span>);<br>    <span class="hljs-comment">// 根据差分数组构造结果数组</span><br>    res[<span class="hljs-number">0</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        res[i] = res[i - <span class="hljs-number">1</span>] + <span class="hljs-variable language_">this</span>.<span class="hljs-property">diff</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>基础题：</p><ul><li>前&#x2F;中&#x2F;后序遍历（递归&#x2F;迭代）#94<ul><li>变形：二叉搜索树的第 k 个节点 #230</li></ul></li><li>层次遍历 #102<ul><li>变形： #107 #116</li></ul></li><li>二叉树的最大深度 #104<ul><li>变形： 平衡二叉树 #110</li></ul></li></ul><p>有趣的题：</p><ul><li>从前序与中序遍历序列构造二叉树 #105</li><li>对称二叉树 #101</li><li>验证二叉搜索树 #98</li></ul><p>树是用来模拟具有树状结构性质的数据集合。根据它的特性可以分为非常多的种类，对于我们来讲，掌握二叉树这种结构就足够了，它也是树最简单、应用最广泛的种类。二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。</p><p><img src="/img/front-end-interview-preparation/DSA-binarytree.png" alt="binary tree"></p><h3 id="1-二叉树的遍历"><a href="#1-二叉树的遍历" class="headerlink" title="1.二叉树的遍历"></a>1.二叉树的遍历</h3><p>二叉树的遍历分成三种，按照根节点的访问先后分为：</p><ul><li>先序遍历（preorder）：先访问根节点，然后访问左子树， 最后访问右子树。</li><li>中序遍历（inorder）：先访问左子树，然后访问根节点， 最后访问右子树。</li><li>后序遍历（postorder）：先访问左子树，然后访问右子树， 最后访问根节点。<br>前&#x2F;中&#x2F;后指的是根元素的位置。</li></ul><p>以中序遍历为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 递归</span><br><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, array = []</span>) &#123;<br>  <span class="hljs-keyword">if</span> (root) &#123;<br>    <span class="hljs-title function_">inorderTraversal</span>(root.<span class="hljs-property">left</span>, array);<br>    array.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>    <span class="hljs-title function_">inorderTraversal</span>(root.<span class="hljs-property">right</span>, array);<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;;<br><span class="hljs-comment">// 迭代（用到了栈）</span><br><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> stack = [], cur = root, res = [];<br>    <span class="hljs-comment">// 指针不是指到null，或栈内有元素</span><br>    <span class="hljs-keyword">while</span>(cur || stack.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-comment">// 1.把当前节点的左子树依次压入栈</span><br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            stack.<span class="hljs-title function_">push</span>(cur);<br>            cur = cur.<span class="hljs-property">left</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2.节点出栈</span><br>        cur = stack.<span class="hljs-title function_">pop</span>();<br>        res.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">val</span>);<br>        <span class="hljs-comment">// 3.以当前节点的右子树为目标节点,重复上述过程</span><br>        cur = cur.<span class="hljs-property">right</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-层次遍历"><a href="#2-层次遍历" class="headerlink" title="2.层次遍历"></a>2.层次遍历</h3><p>用了队列（queue）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];<br><br>    <span class="hljs-keyword">const</span> queue = [], res = [];<br>    queue.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-comment">// 1. 从上到下遍历二叉树的每一层</span><br>    <span class="hljs-keyword">while</span>(queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">const</span> len = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">const</span> temp = [];<br>        <span class="hljs-comment">// 2. 从左到右遍历二叉树的每个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">const</span> cur = queue.<span class="hljs-title function_">shift</span>();<br>            temp.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">val</span>);<br>            <span class="hljs-keyword">if</span>(cur.<span class="hljs-property">left</span>) queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span>(cur.<span class="hljs-property">right</span>) queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(temp);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-二叉树的最大深度"><a href="#3-二叉树的最大深度" class="headerlink" title="3.二叉树的最大深度"></a>3.二叉树的最大深度</h3><p>1.递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">left</span>);<br>    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">right</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left, right) + <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2.递归</p><p>层次遍历的变形</p><h3 id="4-对称二叉树"><a href="#4-对称二叉树" class="headerlink" title="4.对称二叉树"></a>4.对称二叉树</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> isSymmetric = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">helper</span>(root, root);<br>&#125;;<br><br><span class="hljs-keyword">var</span> helper = <span class="hljs-keyword">function</span>(<span class="hljs-params">lTree, rTree</span>)&#123;<br>    <span class="hljs-keyword">if</span>(!lTree &amp;&amp; !rTree) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(!lTree || !rTree) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(lTree.<span class="hljs-property">val</span> === rTree.<span class="hljs-property">val</span> &amp;&amp; <span class="hljs-title function_">helper</span>(lTree.<span class="hljs-property">left</span>, rTree.<span class="hljs-property">right</span>) &amp;&amp; <span class="hljs-title function_">helper</span>(lTree.<span class="hljs-property">right</span>, rTree.<span class="hljs-property">left</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-搜索二叉树"><a href="#5-搜索二叉树" class="headerlink" title="5.搜索二叉树"></a>5.搜索二叉树</h3><p>中序遍历为升序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> isValidBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">let</span> inorder = -<span class="hljs-title class_">Infinity</span>;<br><br>    <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> || root !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">while</span> (root !== <span class="hljs-literal">null</span>) &#123;<br>            stack.<span class="hljs-title function_">push</span>(root);<br>            root = root.<span class="hljs-property">left</span>;<br>        &#125;<br>        node = stack.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span><br>        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">val</span> &lt;= inorder) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        inorder = node.<span class="hljs-property">val</span>;<br>        root = node.<span class="hljs-property">right</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>大O表示法</p>]]></content>
    
    
    <categories>
      
      <category>前端面试基础知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front-end</tag>
      
      <tag>interview</tag>
      
      <tag>data structure</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试基础知识总结（七）：框架</title>
    <link href="/2024/03/15/front-end-interview-preparation-7%20copy/"/>
    <url>/2024/03/15/front-end-interview-preparation-7%20copy/</url>
    
    <content type="html"><![CDATA[<p>Vue，React，Hybrid，微信小程序</p>]]></content>
    
    
    <categories>
      
      <category>前端面试基础知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front-end</tag>
      
      <tag>interview</tag>
      
      <tag>Vue</tag>
      
      <tag>frameworks</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试基础知识总结（六）：计算机网络</title>
    <link href="/2022/10/22/front-end-interview-preparation-6/"/>
    <url>/2022/10/22/front-end-interview-preparation-6/</url>
    
    <content type="html"><![CDATA[<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><img src="/img/front-end-interview-preparation/web-osi-outline.png" alt="OSI七层模型"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/img/front-end-interview-preparation/web-osi.png" alt="OSI七层模型"></p><ul><li>应用层：提供各种网络服务协议</li><li>表示层：用于应用层数据的编码和转换功能</li><li>会话层：负责建立、管理和终止表示层实体之间的通信会话</li><li>传输层：提供端到端的可靠和透明的数据传输服务</li><li>网络层：通过IP寻址来建立两个节点之间的连接</li><li>数据链路层：传输帧</li><li>物理层：传输比特流</li></ul><h3 id="应用层常见的网络协议"><a href="#应用层常见的网络协议" class="headerlink" title="应用层常见的网络协议"></a>应用层常见的网络协议</h3><ul><li>HTTP 超文本传输协议</li><li>SMTP\POP3 邮件发送\接收协议</li><li>FTP 文件传输协议</li><li>DNS 域名系统</li></ul><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><p>TCP协议（传输控制协议）是一种传输层协议，允许数据包从一个位置发送到另一个位置。TCP 是面向连接的协议，也就是说它在网络计算机单元之间的任何通信之前建立连接；同时这个连接将一直保持，直到发送方和接收方完成数据交换。这就是下面介绍的三次握手，四次挥手的过程。</p><p>在UDP协议（用户数据报协议）中，接收方不生成数据包的确认，发送方也不等待数据包的确认。正是这个不足，使得该协议虽不可靠但是速度更快。</p><table><thead><tr><th>区别</th><th>TCP协议</th><th>UDP协议</th></tr></thead><tbody><tr><td>连接</td><td>面向连接协议</td><td>无连接协议</td></tr><tr><td>可靠性</td><td>可靠。接收数据失败时，它会请求重新传输。</td><td>失败时不充发请求。依赖于高层协议来确保可靠性。</td></tr><tr><td>保持数据传输的顺序</td><td>有序接收数据包</td><td>无序接收数据包</td></tr><tr><td>传输速度</td><td>头部开销大，传输更慢</td><td>头部开销小，传输更快</td></tr><tr><td>用例</td><td>用于 HTTPS、HTTP、SMTP、FTP等等。</td><td>用于视频流、视频电话、IP 语音服务（互联网呼叫）、DNS等。</td></tr></tbody></table><h3 id="DNS-域名系统"><a href="#DNS-域名系统" class="headerlink" title="DNS 域名系统"></a>DNS 域名系统</h3><p>DNS 域名系统提供域名到IP地址的转换。</p><p>解析流程：</p><ul><li>优先读取浏览器缓存，系统缓存，本地hosts缓存</li><li>没有再找域名解析服务器，分级查询</li></ul><p><img src="/img/front-end-interview-preparation/web-dns-1.png" alt="DNS解析流程"></p><p>举个例子：</p><blockquote><p><code>www.tmall.com</code>对应的真正的域名为<code>www.tmall.com.</code>。末尾的.称为根域名，因为每个域名都有根域名，因此我们通常省略。<br>根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如.com、.net；<br>再下一级叫做”次级域名”（second-level domain，缩写为SLD），比如<code>www.tmall.com</code>里面的.tmall，这一级域名是用户可以注册的；<br>再下一级是主机名（host），比如<code>www.tmall.com</code>里面的www，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</p></blockquote><p>DNS资源记录：用于把域名解析到相应 IP 地址上</p><p><img src="/img/front-end-interview-preparation/web-dns-2.png" alt="DNS资源记录"></p><ul><li>记录类型中 A 记录指向 IP 地址，CNAME 记录指向域名，常用于 CDN</li><li>TTL(生存周期)：一般的域名解析商都有默认值，阿里云为10分钟</li></ul><h2 id="TCP三次握手、四次挥手"><a href="#TCP三次握手、四次挥手" class="headerlink" title="TCP三次握手、四次挥手"></a>TCP三次握手、四次挥手</h2><p><img src="/img/front-end-interview-preparation/web-tcp34.png" alt="TCP三次握手、四次挥手"></p><p>TCP 通过三次握手建立一个连接，四次挥手关闭一个连接。这也是 TCP 协议面向连接的深层含义。</p><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。前两次挥手，只是断开连接这件事做确认，但并不会立即行这件事。第三次挥手前，服务器会把自己想传的数据传输完，然后再通知一次客户端。第四次挥手，客户端接收并响应来自服务端的分手请求。</p><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手。为什么终止时会多一次呢？</p><ul><li>这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</li></ul><p>概括如下：</p><table><thead><tr><th></th><th>三次握手</th><th>四次挥手</th></tr></thead><tbody><tr><td>前两次</td><td>对创建连接这件事做确认</td><td>对断开连接这件事做确认</td></tr><tr><td>第三次</td><td>创建连接</td><td>服务器最后一次传输需要的数据</td></tr><tr><td>第四次</td><td>&#x2F;</td><td>关闭连接</td></tr></tbody></table><h3 id="【高阶】三次握手"><a href="#【高阶】三次握手" class="headerlink" title="【高阶】三次握手"></a>【高阶】三次握手</h3><p>首先，先解释一下三次握手过程中会出现的报文：</p><ul><li>SYN 同步报文：SYN 置1就表示这是一个连接请求或连接接受报文</li><li>ACK 确认报文：只有ACK&#x3D;1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</li><li>seq 序列号：客户端、服务端都要初始序列号，第二个报文段则 + 1</li><li>ack 确认码：接受到的对方的序列号 + 1</li></ul><p>三次握手的过程：</p><ol><li>客户端：首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x（指定客户端的初始化序列号）。</li><li>服务端：在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1（把客户端的初始化序列号 + 1作为ACK的值），初始序号seq&#x3D;y（指定服务端的初始化序列号）。</li><li>客户端：确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1）。</li></ol><p><img src="/img/front-end-interview-preparation/three-way-handshake.png" alt="三次握手"></p><h3 id="【高阶】四次挥手"><a href="#【高阶】四次挥手" class="headerlink" title="【高阶】四次挥手"></a>【高阶】四次挥手</h3><p>其中，FIN报文用来释放一个连接。FIN&#x3D;1 时，就表示此报文段的发送方的数据已经发送完毕，请求释放运输连接。</p><p>四次挥手的过程：</p><ol><li>客户端：FIN&#x3D;1请求释放连接，seq&#x3D;u（指定客户端的序列号）。</li><li>服务端：在确认报文段中ACK&#x3D;1，确认号ack&#x3D;u+1，初始序号seq&#x3D;v（指定服务端的初始化序列号）。</li><li>服务端：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个新的序列号。服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1）。</li><li>客户端：确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1）</li></ol><p><img src="/img/front-end-interview-preparation/four-way-handshake.png" alt="四次挥手"></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><img src="/img/front-end-interview-preparation/web-http.png" alt="HTTP"></p><h3 id="对HTTP无状态的理解"><a href="#对HTTP无状态的理解" class="headerlink" title="对HTTP无状态的理解"></a>对HTTP无状态的理解</h3><p>HTTP是无状态的，意味着两个请求之间毫无关系。如果想要维持不同请求间的状态信息，需要其他手段，比如cookie-session，这部分内容会在<a href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E9%89%B4%E6%9D%83">前后端鉴权</a>中介绍。</p><h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>请求报文的结构如下：</p><ul><li>请求行：请求方法、URL以及协议版本。它们用空格分隔，如<code>GET /index.html HTTP/1.1</code>。</li><li>请求头部：请求头部由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔</li><li>请求体：post、put等请求携带的数据</li></ul><p><img src="/img/front-end-interview-preparation/web-request-packets.png" alt="请求报文的报文结构"></p><p>响应报文的结构如下：</p><ul><li>状态行：协议版本，状态码，状态码描述。如<code>HTTP/1.1 200 OK</code>。</li><li>响应头部：响应首部组成。</li><li>响应正文：服务器响应的数据。</li></ul><h3 id="常见的首部字段"><a href="#常见的首部字段" class="headerlink" title="常见的首部字段"></a>常见的首部字段</h3><p>通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部</p><p>常见的请求头：</p><ul><li>Authorization: 验证信息</li><li>Accept： 浏览器能够接收的内容类型，如 text&#x2F;html</li><li>Accept-Encoding： 浏览器能解码的编码类型，如gzip, deflate</li><li>Connection: 是否需要持久连接，HTTP1.1默认值为keep-alive</li><li>Cookie: 会话追踪</li><li>Host：请求资源所在服务器 </li><li>User-Agent: 用户代理信息</li><li>Content-Type: GET请求无该字段，POST请求常见值有：application&#x2F;x-www-form-urlencoded, multipart&#x2F;form-data</li><li>If-Match：比较实体标记（ETage）</li><li>If-Modified-Since：比较资源更新时间（Last-Modified）</li></ul><p>常见的响应头：</p><ul><li>Last-Modified： 资源在服务器的最后修改时间</li><li>ETag：能够表示资源唯一资源的字符串</li><li>Expires： 相应过期的时间</li><li>Set-Cookie: 设置Cookie</li><li>Content-Encoding: 文档的编码方法</li><li>Content-Length: 内容的长度</li><li>Content-Type: 文档的MIME类型</li></ul><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><h4 id="HTTP请求方法及作用"><a href="#HTTP请求方法及作用" class="headerlink" title="HTTP请求方法及作用"></a>HTTP请求方法及作用</h4><p>HTTP1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。<br>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><table><thead><tr><th>HTTP Methods</th><th>描述</th><th>安全性</th><th>幂等性</th></tr></thead><tbody><tr><td>GET</td><td>仅用作数据的读取</td><td>√</td><td>√</td></tr><tr><td>HEAD</td><td>只请求页面的首部,不请求页面内容,用于检查源有效性</td><td>√</td><td>√</td></tr><tr><td>POST</td><td>创建新资源或修改现有资源</td><td>x</td><td>x</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td><td>x</td><td>√</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新</td><td>x</td><td>x</td></tr><tr><td>DELETE</td><td>删除指定的资源</td><td>x</td><td>√</td></tr><tr><td>OPTIONS</td><td>获取指定服务能够支持的通信选项</td><td>√</td><td>√</td></tr><tr><td>CONNECT</td><td>HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器</td><td>x</td><td>x</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td><td>√</td><td>√</td></tr></tbody></table><p>安全性：指该方法多次调用不会产生副作用，即不改变资源状态。</p><ul><li>安全的方法：GET，HEAD，OPTIONS和TRACE</li></ul><p>幂等性：该方法多次调用返回的结果一致。</p><ul><li>幂等的方法：GET，HEAD，OPTIONS，TRACE，PUT和DELETE。</li><li>所有安全的HTTP方法都是幂等的，但PUT和DELETE是幂等的，但并不安全。</li></ul><p>有疑问可以看看这篇文章：<a href="https://www.jianshu.com/p/bee85cf4e33a">POST,PUT和PATCH的区别</a></p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1xx</td><td>信息性，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2xx</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3xx</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4xx</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5xx</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>常见的HTTP状态码列表:</p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>304</td><td>Not Modified</td><td>协商缓存生效。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr></tbody></table><h2 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h2><p><img src="/img/front-end-interview-preparation/web-http2.png" alt="HTTP/2.0"></p><h3 id="HTTP-x2F-1-0的痛点"><a href="#HTTP-x2F-1-0的痛点" class="headerlink" title="HTTP&#x2F;1.0的痛点"></a>HTTP&#x2F;1.0的痛点</h3><ol><li>短连接：TCP消耗大</li><li>队头阻塞问题：每个TCP同时只能处理一个HTTP请求，浏览器遵循FIFO原则，如果上一个没返回后续请求会被阻塞。</li></ol><h3 id="HTTP-x2F-1-1的优化"><a href="#HTTP-x2F-1-1的优化" class="headerlink" title="HTTP&#x2F;1.1的优化"></a>HTTP&#x2F;1.1的优化</h3><ol><li>实现长连接：减少TCP连接消耗：<ul><li>请求头配置：<code>Connection:keep-alive = true</code>。只要tcp连接不断开（默认2小时），一直可以进行http请求，但是一个tcp连接同一时间只支持一个http请求</li></ul></li><li>线管化：允许多个HTTP请求批量地提交给服务器<ul><li>这样做不能从根本上解决队头阻塞问题（虽然发送请求可以并行了，但响应还是串行）</li></ul></li></ol><h3 id="HTTP-x2F-2-0的优化"><a href="#HTTP-x2F-2-0的优化" class="headerlink" title="HTTP&#x2F;2.0的优化"></a>HTTP&#x2F;2.0的优化</h3><ol><li>多路复用：一个tcp可以并发多个http请求<ul><li>理论无上限，但是一般浏览器会有tcp并发数的限制，chrome为6个。</li></ul></li><li>二进制分帧：在应用层(HTTP)和传输层(TCP)之间增加一个二进制分帧层，从而改进传输性能。<ul><li>HTTP 1.1在应用层以纯文本的形式进行通信；而HTTP 2.0将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。</li><li>在二进制分帧层上，HTTP 1.1的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。</li></ul></li><li>头部压缩<ul><li>原因：请求头字段很多都是重复的，比如Cookie，会浪费很多带宽。所以，对于相同的头部，只需发送一次即可。</li><li>压缩机制：<ul><li>客户端通过 gzip 和 compress 压缩头部然后再发送请求。</li><li>客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。</li></ul></li></ul></li><li>支持服务端推送<ul><li>客户端发送一个请求，服务器根据客户端的请求，提前返回多个响应，这样客户端就不用发起后续请求。</li><li>例子：如果一个请求是由主页发送的，服务器可能会响应主页内容、logo以及样式表，因为它知道客户端会用到这些。</li></ul></li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><img src="/img/front-end-interview-preparation/web-https.png" alt="HTTPS"></p><h3 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h3><table><thead><tr><th>HTTP的缺点</th><th>HTTPS的改进</th></tr></thead><tbody><tr><td>通信使用明文，可能会被窃听</td><td>加密</td></tr><tr><td>不验证通信方的身份，可能遭遇伪装</td><td>认证</td></tr><tr><td>无法证明报文完整性，可能已遭篡改</td><td>完整性保护</td></tr></tbody></table><h3 id="HTTPS的改进"><a href="#HTTPS的改进" class="headerlink" title="HTTPS的改进"></a>HTTPS的改进</h3><p>HTTPS &#x3D; HTTP + 加密 + 认证 + 完整性保护。</p><p>HTTPS 不是应用层的新协议，而是 HTTP 通信接口部分用 SSL 和 TLS 协议替换了。HTTPS先和SSL通信，再由SSL和TCP通信。</p><blockquote><p>TLS 和 SSL 的区别：<br>TLS 是传输层安全的缩写，SSL 是安全套接字层的缩写，都是验证连接的加密协议<br>TLS 实际上只是 SSL 的更新版本，它修复了早期 SSL 协议中的一些安全漏洞。</p></blockquote><h3 id="非对称密钥加密技术"><a href="#非对称密钥加密技术" class="headerlink" title="非对称密钥加密技术"></a>非对称密钥加密技术</h3><table><thead><tr><th>区别</th><th>对称密钥加密</th><th>非对称密钥加密</th></tr></thead><tbody><tr><td>算法</td><td>加密解密使用相同的密钥</td><td>加密解密使用一对非对称的密钥：私有密钥 + 公开密钥。<br/> 1. 公开密钥加密，私有密钥解密。<br/> 2. 私有密钥签名，公开密钥验签。</td></tr><tr><td>优势</td><td>算法更简单，运行效率高</td><td>安全性高，不必担心私有密钥被窃听，内容被解密</td></tr></tbody></table><h3 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h3><p>HTTPS充分利用两种技术的优势，组合起来用于通信：</p><ol><li>客户端获取公钥<ul><li>服务端生成公私钥对，并把公钥安全地传输给客户端</li></ul></li><li>在交换密钥阶段：非对称加密<ul><li>客户端用公钥加密 Key，服务端用私钥解密。</li><li>目的：安全地交换稍后要用到的密钥 Key。</li></ul></li><li>建立通信交换报文阶段：对称加密<ul><li>确保交换的密钥 Key 是安全的后，使用对称加密方式通信。</li></ul></li></ol><p><img src="/img/front-end-interview-preparation/web-key.png" alt="混合加密的机制"></p><p>但是第一阶段仍有问题，那就是无法证明客户端获得的公钥确实是服务器发行的公钥。数字证书认证机构（CA）的出现解决了这个问题。</p><h3 id="数字证书认证机构"><a href="#数字证书认证机构" class="headerlink" title="数字证书认证机构"></a>数字证书认证机构</h3><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务端双方都信赖的第三方机构。</p><p>业务流程如下：</p><ol><li>服务端将自己的公钥传给CA</li><li>CA用自己的私钥对服务器公钥签名，并颁发公钥证书（服务器公钥 + CA的数字签名）</li><li>客户端拿到公钥证书，使用<em>CA的公钥</em>对签名验签，确认服务器公钥的真实性</li></ol><p>那么如何拿到CA的公钥呢？</p><ul><li>多数浏览器内置常用认证机构的公钥。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>应用层发送数据时会附加一种叫做MAC的报文摘要。MAC能够查知报文是否已经遭到篡改，从而保护报文的完整性。</p><h2 id="前端请求方式"><a href="#前端请求方式" class="headerlink" title="前端请求方式"></a>前端请求方式</h2><p><img src="/img/front-end-interview-preparation/web-ajax.png" alt="混合加密的机制"></p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>Ajax（Asynchronous JavaScript And XML，即异步JavaScript和XML），这一技术能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。Ajax 有两种原生的实现规范：</p><ol><li>XMLHttpRequest（XHR）：现代浏览器，最开始与服务器交换数据，都是通过 XMLHttpRequest 对象。</li><li>fetch：ES6后出现，基于 promise 设计。</li></ol><p>狭义上的Ajax专指基于原生的XHR的实现方式。</p><h3 id="XHR"><a href="#XHR" class="headerlink" title="XHR"></a>XHR</h3><p>缺点：</p><ul><li>使用起来也比较繁琐，需要设置很多值</li><li>早期的IE浏览器有自己的实现，这样需要写兼容代码</li></ul><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>fetch API提供了一个 JavaScript 接口，用于访问和操作HTTP管道的部分，例如请求和响应。它还提供了一个全局fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p><p>优势：跨域的处理，在配置中添加<code>mode: &#39;no-cors&#39;</code>就可以跨域了</p><p>fetch目前遇到的问题：</p><ul><li>fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</li><li>fetch默认不会带cookie，需要添加配置项。</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费。</li><li>fetch没有办法原生监测请求的进度，而XHR可以。</li></ul><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p>Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。</p><p>优点：</p><ul><li>从浏览器中创建XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 CSRF</li></ul><p>缺点：</p><ul><li>只持现代代浏览器</li></ul><h2 id="跨域及解决方案"><a href="#跨域及解决方案" class="headerlink" title="跨域及解决方案"></a>跨域及解决方案</h2><p><img src="/img/front-end-interview-preparation/web-cross-domain.png" alt="跨域及解决方案"></p><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，是广义的，通常包括：</p><ol><li>资源跳转：A链接、重定向</li><li>资源嵌入：<code>&lt;script&gt;</code>,<code>&lt;frame&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;img&gt;</code>等dom标签</li><li>脚本请求：js发起的ajax请求、dom和js对象的跨域操作等</li></ol><p>我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。</p><h4 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h4><p>同源策略&#x2F;SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>同源策略限制以下几种行为：</p><ol><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM 和 Js 对象无法获得</li><li>AJAX 请求不能发送</li></ol><p>这里提到的 Cookie 作用域有点特殊，详见下文。</p><h4 id="Cookie的作用域"><a href="#Cookie的作用域" class="headerlink" title="Cookie的作用域"></a>Cookie的作用域</h4><p>Cookie有两个很重要的属性:Domain和Path，用来指示此Cookie的作用域：</p><ul><li>Domain：当前要添加的Cookie的域名归属，如果没有明确指明则默认为当前域名</li><li>Path：当前要添加的Cookie的路径归属，如果没有明确指明则默认为当前路径</li></ul><p>浏览器提交的Cookie需要满足以下两点： </p><ol><li>当前域名或者父域名下的Cookie；</li><li>当前路径或父路径下的Cookie。</li></ol><p>注意：在浏览器看来. <a href="http://www.domain.com不是test.domain.com的父域名,而domain.com才是test.domain.com的父域名/">www.domain.com不是test.domain.com的父域名，而domain.com才是test.domain.com的父域名</a>.</p><h4 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h4><p>主要介绍以下四种：</p><ol><li>跨域资源分享（CORS）</li><li>JSONP 跨域</li><li>Nginx 代理跨域</li><li>postMessage 跨域</li></ol><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要<strong>浏览器和服务器</strong>同时支持。<br>浏览器将CORS跨域请求分为简单请求和非简单请求。</p><h4 id="简单请求和非简单请求的区别"><a href="#简单请求和非简单请求的区别" class="headerlink" title="简单请求和非简单请求的区别"></a>简单请求和非简单请求的区别</h4><p>简单请求和非简单请求的概念是针对跨源域资源共享而言的。跨源域资源共享（CORS）机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。</p><p>其中，简单请求不会触发 CORS 预检请求,而非简单请求会触发预检请求（即该请求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求）。</p><p>若请求满足所有下述条件，则该请求可视为“简单请求”：</p><ul><li>请求方法：GET、HEAD、POST</li><li>除了被用户代理自动设置的首部字段（例如 Connection，User-Agent）和在 Fetch 规范中定义为禁用首部名称的其他首部，允许<strong>人为设置</strong>的字段为 Fetch 规范定义的 对 CORS 安全的首部字段集合。该集合为：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type：只限于三个值：application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li></ul></li><li>请求中的任意 XMLHttpRequest 对象均没有注册任何事件监听器；XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。</li><li>请求中没有使用 ReadableStream 对象。</li></ul><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>CORS请求设置的响应头字段，都以 Access-Control-开头：</p><ol><li><code>Access-Control-Allow-Origin</code>：必选，<ul><li>它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li></ul></li><li><code>Access-Control-Allow-Credentials</code>：可选<ul><li>它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。</li></ul></li><li><code>Access-Control-Expose-Headers</code>：可选<ul><li>CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</li></ul></li></ol><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。服务端根据预检请求选择是否允许该跨域请求。</p><p>预检请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段：</p><ol><li><code>Access-Control-Request-Method</code>：必选<ul><li>用来列出浏览器的CORS请求会用到哪些HTTP方法。</li></ul></li><li><code>Access-Control-Request-Headers</code>：可选<ul><li>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</li></ul></li></ol><p>预检请求的响应：</p><p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。<br> <br>请求响应中，除了关键的<code>Access-Control-Allow-Origin</code> 和<code>Access-Control-Allow-Credentials</code>字段，其他CORS相关字段如下：</p><ol><li><code>Access-Control-Allow-Methods</code>：必选<ul><li>它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</li></ul></li><li><code>Access-Control-Allow-Headers</code><ul><li>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则该字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li></ul></li><li><code>Access-Control-Max-Age</code>：可选<ul><li>用来指定本次预检请求的有效期，单位为秒。</li></ul></li></ol><h3 id="JSONP-跨域"><a href="#JSONP-跨域" class="headerlink" title="JSONP 跨域"></a>JSONP 跨域</h3><p>同源限制是跨域限制的本质。存在一些标签没有同源限制，像<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;img&gt;</code>等标签。jsonp的原理是通过script标签跳过同源限制。基于此原理，可以通过动态创建<code>&lt;script&gt;</code>，再请求一个带参网址实现跨域通信。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ol><li><p>客户端：定义 callback，callback内是读取数据的逻辑。</p> <figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);</span><br><span class="language-javascript">    script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javascript&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span><br><span class="language-javascript">    script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 回调执行函数</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCallback</span>(<span class="hljs-params">res</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res));</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>服务端：输出对 callback 的调用（即<code>handleCallback(res)</code>），把目标数据作为入参传给 callback</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> urllib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>);<br><br><span class="hljs-keyword">var</span> port = <span class="hljs-number">8080</span>;<br><span class="hljs-comment">// 目标数据</span><br><span class="hljs-keyword">var</span> data = &#123;<span class="hljs-string">&#x27;data&#x27;</span>:<span class="hljs-string">&#x27;world&#x27;</span>&#125;;<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;<br>    <span class="hljs-keyword">var</span> params = urllib.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>,<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span>(params.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span>)&#123;<br>        <span class="hljs-comment">// 把目标数据作为入参传给 callback</span><br>        <span class="hljs-keyword">var</span> str = params.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span> + <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>        res.<span class="hljs-title function_">end</span>(str);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.<span class="hljs-title function_">end</span>();<br>    &#125;<br>    <br>&#125;).<span class="hljs-title function_">listen</span>(port,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;jsonp server is on&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>客户端：接收到返回的 JS 脚本，开始解析和执行<code>handleCallback(res)</code></p></li></ol><h3 id="Nginx-代理跨域"><a href="#Nginx-代理跨域" class="headerlink" title="Nginx 代理跨域"></a>Nginx 代理跨域</h3><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口。并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># proxy服务器</span><br>server &#123;<br>    listen       81;<br>    server_name  www.domain1.com;<br><br>    location / &#123;<br>        proxy_pass   http://www.domain2.com:8080;  <span class="hljs-comment">#反向代理</span><br>        proxy_cookie_domain www.domain2.com www.domain1.com; <span class="hljs-comment">#修改cookie里域名</span><br>        index  index.html index.htm;<br><br>        <span class="hljs-comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br>        add_header Access-Control-Allow-Origin http://www.domain1.com;  <span class="hljs-comment">#当前端只跨域不带cookie时，可为*</span><br>        add_header Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="postMessage-跨域"><a href="#postMessage-跨域" class="headerlink" title="postMessage 跨域"></a>postMessage 跨域</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li></ul><p>用法：<code>postMessage(data, origin)</code>方法接受两个参数：</p><ul><li>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li><li>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”&#x2F;“。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>1). a.html：(<a href="http://www.domain1.com/a.html">www.domain1.com/a.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">       </span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span><br><span class="language-javascript">    iframe.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> data = &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aym&#x27;</span></span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        <span class="hljs-comment">// 向domain2传送跨域数据</span></span><br><span class="language-javascript">        iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">&#x27;http://www.domain2.com&#x27;</span>);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 接受domain2返回数据</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2). b.html：(<a href="http://www.domain1.com/b.html">www.domain1.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 接收domain1的数据</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (data) &#123;</span><br><span class="language-javascript">            data.<span class="hljs-property">number</span> = <span class="hljs-number">16</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">// 处理后再发回domain1</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="前后端鉴权"><a href="#前后端鉴权" class="headerlink" title="前后端鉴权"></a>前后端鉴权</h2><p><img src="/img/front-end-interview-preparation/web-jwt-session.png" alt="web-jwt-session"></p><h3 id="认证与授权的关系"><a href="#认证与授权的关系" class="headerlink" title="认证与授权的关系"></a>认证与授权的关系</h3><ul><li>认证（Authentication）<br>认证涉及一方应用和一方用户，用于描述用户在该应用下的身份。认证可以简单理解为登录，以此确认你是一个合法的用户。</li><li>授权（Authorisation）<br>授权涉及两方应用和一方用户，用于描述第三方应用有哪些操作权限。</li></ul><h3 id="常见鉴权方式"><a href="#常见鉴权方式" class="headerlink" title="常见鉴权方式"></a>常见鉴权方式</h3><h4 id="Session-Cookie"><a href="#Session-Cookie" class="headerlink" title="Session-Cookie"></a>Session-Cookie</h4><p>Session-Cookie 的认证流程如下：</p><ol><li>用户向服务器发送用户名和密码。</li><li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li><li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li><li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li><li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li></ol><p>简单来说：</p><ul><li>Session 保存在服务端，是单用户的会话状态。</li><li>Cookie 保存在客户端，每次向服务器发送请求是都会带上这个cookie。</li></ul><h4 id="Token认证"><a href="#Token认证" class="headerlink" title="Token认证"></a>Token认证</h4><p>与上面的Session-Cookie 机制不同的地方在于，基于 token 的用户认证是一种服务端无状态的认证方式，服务端可以不用存放token 数据，但是服务器可以验证 token 的合法性和有效性。</p><p>使用token 进行认证的方式主要有两种：SAML 和 JWT。这里介绍JWT（Json Web Token）。</p><h5 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h5><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;姓名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;张三&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;角色&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;管理员&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;到期时间&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018年7月1日0点0分&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><h5 id="JWT-的结构"><a href="#JWT-的结构" class="headerlink" title="JWT 的结构"></a>JWT 的结构</h5><ul><li>Header（头部）：声明类型和加密算法</li><li>Payload（负载）：存放有效信息的地方</li><li>Signature（签名）：对前两部分的签名，防止数据篡改</li></ul><p><strong>1.Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span> <span class="hljs-comment">// 表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><p><strong>2.Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。除了官方字段，也可以定义私有字段。也要使用 Base64URL 算法转成字符串。</strong></p><blockquote><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></blockquote><p><strong>3.Signature 部分是对前两部分的签名，防止数据篡改。</strong></p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">HMACSHA256</span>(<br>  <span class="hljs-title function_">base64UrlEncode</span>(header) + <span class="hljs-string">&quot;.&quot;</span> +<br>  <span class="hljs-title function_">base64UrlEncode</span>(payload),<br>  secret)<br></code></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li>有效期短，只希望被使用一次。<blockquote><p>比如，用户注册后发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户，一次性的。</p></blockquote></li><li>jwt中的payload是base64编码的，没有加密，因此不能存储敏感数据</li></ol><h4 id="OAuth2-0-授权"><a href="#OAuth2-0-授权" class="headerlink" title="OAuth2.0 授权"></a>OAuth2.0 授权</h4><p>允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息。</p><h5 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h5><p>OAuth 2.0的运行流程如下图，摘自<a href="http://www.rfcreader.com/#rfc6749">RFC 6749</a>:</p><div class="code-wrapper"><pre><code class="hljs">+--------+                               +---------------+|        |--(A)- Authorization Request -&gt;|   Resource    ||        |                               |     Owner     ||        |&lt;-(B)-- Authorization Grant ---|               ||        |                               +---------------+|        ||        |                               +---------------+|        |--(C)-- Authorization Grant --&gt;| Authorization || Client |                               |     Server    ||        |&lt;-(D)----- Access Token -------|               ||        |                               +---------------+|        ||        |                               +---------------+|        |--(E)----- Access Token ------&gt;|    Resource   ||        |                               |     Server    ||        |&lt;-(F)--- Protected Resource ---|               | +--------+                               +---------------+           Figure 1: Abstract Protocol Flow</code></pre></div><p>重点在于B步骤：用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><h5 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h5><p>OAuth 2.0定义了四种授权方式：授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）、客户端模式（client credentials）。</p><p><strong>授权码模式</strong>是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p><div class="code-wrapper"><pre><code class="hljs"> +----------+ | Resource | |   Owner  | |          | +----------+      ^      |     (B) +----|-----+          Client Identifier      +---------------+ |         -+----(A)-- &amp; Redirection URI ----&gt;|               | |  User-   |                                 | Authorization | |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    | |          |                                 |               | |         -+----(C)-- Authorization Code ---&lt;|               | +-|----|---+                                 +---------------+   |    |                                         ^      v  (A)  (C)                                        |      |   |    |                                         |      |   ^    v                                         |      | +---------+                                      |      | |         |&gt;---(D)-- Authorization Code ---------&#39;      | |  Client |          &amp; Redirection URI                  | |         |                                             | |         |&lt;---(E)----- Access Token -------------------&#39; +---------+       (w/ Optional Refresh Token)</code></pre></div><p>步骤如下：</p><p>（A）用户访问客户端，后者将前者导向认证服务器。</p><p>（B）用户选择是否给予客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p><p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p><p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p><p>下面是这些步骤所需要的参数：</p><p>（A）客户端申请认证的URI，包含以下参数：</p><ul><li>response_type：表示授权类型，必选项，此处的值固定为”code”</li></ul><ul><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URI，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。（用于预防CSRF攻击）</li></ul><blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz<br>        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<br></code></pre></td></tr></table></figure></blockquote><p>（C）服务器回应客户端的URI，包含以下参数：</p><ul><li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">302</span> Found<br><span class="hljs-attribute">Location</span><span class="hljs-punctuation">: </span>https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA<br>          &amp;state=xyz<br></code></pre></td></tr></table></figure></blockquote><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li>client_id：表示客户端ID，必选项。</li></ul><p>下面是一个例子。</p><blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/token</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><br><span class="language-llvm">grant_type<span class="hljs-operator">=</span>authorization_code&amp;code<span class="hljs-operator">=</span>SplxlOBeZQQYbYS<span class="hljs-number">6</span>WxSbIA</span><br><span class="language-llvm">&amp;redirect_uri<span class="hljs-operator">=</span>https<span class="hljs-variable">%3</span>A<span class="hljs-variable">%2</span>F<span class="hljs-variable">%2</span>Fclient<span class="hljs-variable">%2</span>Eexample<span class="hljs-variable">%2</span>Ecom<span class="hljs-variable">%2</span>Fcb</span><br></code></pre></td></tr></table></figure></blockquote><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ul><p>下面是一个例子。</p><blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json;charset=UTF-8<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-store<br><span class="hljs-attribute">Pragma</span><span class="hljs-punctuation">: </span>no-cache<br><br><span class="language-json"><span class="hljs-punctuation">&#123;</span></span><br><span class="language-json">  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2YotnFZFEjr1zCsicMWpAA&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json">  <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;example&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json">  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">3600</span><span class="hljs-punctuation">,</span></span><br><span class="language-json">  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json">  <span class="hljs-attr">&quot;example_parameter&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;example_value&quot;</span></span><br><span class="language-json"><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure></blockquote><p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application&#x2F;json）。此外，HTTP头信息中明确指定不得缓存。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://chinese.freecodecamp.org/news/tcp-vs-udp-which-is-faster/">tcp vs udp</a></li><li><a href="https://juejin.cn/post/6844903958624878606">面试官，不要再问我三次握手和四次挥手</a></li><li><a href="https://juejin.cn/post/6844903865410650126">面试官（9）：可能是全网最全的http面试答案</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">MDN: CORS</a></li><li><a href="https://www.runoob.com/http/http-methods.html">菜鸟教程：HTTP Methods</a></li><li><a href="https://www.jdon.com/53766">HTTP有哪些保证幂等性和安全性的方法？ - mscharhag</a></li><li><a href="https://www.runoob.com/http/http-status-codes.html">菜鸟教程：HTTP 状态码</a></li><li><a href="https://segmentfault.com/a/1190000023110443">前后端鉴权二三事</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程</a></li><li><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0</a></li><li><a href="https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案（全）</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端面试基础知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front-end</tag>
      
      <tag>interview</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>What is Aromanticism?</title>
    <link href="/2022/05/30/aromantic/"/>
    <url>/2022/05/30/aromantic/</url>
    
    <content type="html"><![CDATA[<h2 id="Sexual-Orientation-amp-Romantic-Orientation"><a href="#Sexual-Orientation-amp-Romantic-Orientation" class="headerlink" title="Sexual Orientation &amp; Romantic Orientation"></a>Sexual Orientation &amp; Romantic Orientation</h2><p>Most people are unfamiliar with the term “Aromantic”.  Aromantic people, in brief, have little or no romantic attraction to others. You may be familiar with the term “Asexual”.  But it’s different. Individuals who are asexual have little or no sexual attraction to others. Take a look at the illustration below:</p><p><img src="/img/aromantic-and-asexual.png" alt="Aromantic &amp; Asexual"></p><p>You’re probably smart enough to tell the difference. It’s actually the distinction between sexual and romantic orientations. Five distinct orientations are shown in the table below.</p><table><thead><tr><th>Descriptation</th><th>Sexual Orientation</th><th>Romantic Orientation</th></tr></thead><tbody><tr><td>Attracted to people of a different gender</td><td>Straight&#x2F;Heterosexual</td><td>Heteroromantic</td></tr><tr><td>Attracted to people of the same gender</td><td>Gay&#x2F;Lesbian&#x2F;Homosexual</td><td>Homoromantic</td></tr><tr><td>Attracted to more than one gender of people</td><td>Bisexual</td><td>Biromantic</td></tr><tr><td>Attracted to people of all genders&#x2F;regardless of gender</td><td>Pansexual</td><td>Panromantic</td></tr><tr><td>Attracted to people rarely, weakly, or not at all</td><td>Asexual</td><td>Aromantic</td></tr></tbody></table><h2 id="Characteristics-of-Aromanticism"><a href="#Characteristics-of-Aromanticism" class="headerlink" title="Characteristics of Aromanticism"></a>Characteristics of Aromanticism</h2><p>Some signs that you might be aromantic include:</p><ul><li>You don’t experience feelings of romantic attraction.</li><li>You feel that you do not need a romantic relationship to feel complete or fulfilled.</li><li>You don’t experience “crushes” or being “in love” with someone else.</li><li>You have a hard time relating to romantic stories.</li></ul><h2 id="Aromantic-Spectrum"><a href="#Aromantic-Spectrum" class="headerlink" title="Aromantic Spectrum"></a>Aromantic Spectrum</h2><p>Everyone’s experience is unique, so feelings about romance and relationships can vary greatly among aromantic people. Like other sexual orientations, Aromanticism is a spectrum. Different people have different level of ramantic attraction to others. The aromantic flag shows the spectrum:</p><p><img src="/img/aromantic-flag.jpg" alt="the meaning of the Aromantic flag"></p><ul><li>Gray - Gray-romantic: These terms refer to individuals who fall somewhere in the middle of aromantic and romantic. They may experience some romantic feelings but only under certain conditions.</li><li>Black - WTF-romantic: someone who finds romantic attraction confusing, or cannot differentiate between platonic and romantic attraction, or is unsure of whether they experience romantic attraction.</li></ul><h2 id="My-story-about-how-I-realized-I’m-aromantic"><a href="#My-story-about-how-I-realized-I’m-aromantic" class="headerlink" title="My story about how I realized I’m aromantic"></a>My story about how I realized I’m aromantic</h2><p>In my nation, most parents forbid their children from having a girlfriend or boyfriend. They believe that the most essential thing for their children at this age is to work hard and earn good grades so that they can attend the best universities. As a direct consequence, I rarely consider romantic relationships before going to college. For us, staying alone is the most normal option.</p><p>When I was in college, my roommates would frequently discuss their crushes. I don’t know how they could have a crush on others so simply. When people asked me, “What would your perfect boyfriend look like?” I realized I’ve never imagined my ideal partner’s characteristics. In fact, I really enjoy romantic stories, but I don’t think it’ll ever happen to me. It will not be romantic if it occurs to me. It will be lengthy and tedious. </p><p>“Be single is pathetic.” they said, “When you ages, you will know what I mean.”</p><p>I began to wonder why there are numerous festivals dedicated to lovers and why I am different from others. Then I came across the term Aromantic. After consulting the explanation, I was relieved to learn that the term “explain who I am” exists! I regain my confidence! I don’t need a romantic relationship to feel fulfilled. </p><p>I’d want to clarify that being aromantic does not imply that we don’t feel love or any romantic attractions. Under certain circumstances, I may feel romantic desires. But it’s too short, and I don’t think I want the romantic attraction to turn into a real relationship.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://warwick.ac.uk/services/wss/topics/sexuality_and_coming_out/">Sexuality, Sexual and Romantic Orientation, and ‘Coming Out’</a></li><li><a href="https://www.verywellmind.com/what-does-it-mean-to-be-aromantic-5189571">What Does It Mean to Be Aromantic?</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Notes of Living</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>English Learning Skills &amp; English Materials Recommendation</title>
    <link href="/2022/05/28/english-learning-skills/"/>
    <url>/2022/05/28/english-learning-skills/</url>
    
    <content type="html"><![CDATA[<p>For the past six months, I’ve been studying English in my spare time and have made significant progress. Though I’m not a fluent English speaker yet, I still want to share my thoughts in English and as for me, it’s a good chance to practice my writing skills. So, in this article, I’ll share my English learning experiences in the hopes that it would be useful to you.</p><p>In the first part, I’ll talk about top 5 practical skills, and In the second part, I’ll introduce my favorite English materials.</p><h2 id="English-Learning-Skills"><a href="#English-Learning-Skills" class="headerlink" title="English Learning Skills"></a>English Learning Skills</h2><ol><li>stimulate your interest in English.</li><li>get used to the native English environment.</li><li>build up English mind.</li><li>try to create, not just accept.</li><li>be patient with yourself.</li></ol><h3 id="1-stimulate-your-interest-in-English"><a href="#1-stimulate-your-interest-in-English" class="headerlink" title="1.stimulate your interest in English."></a>1.stimulate your interest in English.</h3><p>The most important thing is to ignite your interest in the English language. If you read or listen to some English materials every day in your leisure time, you will spend far more time on English materials than you will in class, and you will make enormous progress without painstaking effort!</p><p>Textbooks are so boring! Why not try some tv series or viedo games? For instance, I guess many people like watching tv series on Netflix or playing games on Steam. All you need to do is to keep your habit and switch the language to English. You may find it difficult to adjust at first, but after you do, you’ll be so engrossed in the show that you’ll forget you’re watching it in English! That’s the second thing I’d like to mention!</p><h3 id="2-get-used-to-the-native-English-environment"><a href="#2-get-used-to-the-native-English-environment" class="headerlink" title="2.get used to the native English environment."></a>2.get used to the native English environment.</h3><p>The English you learned in school is not the same as the English you will encounter in the real world. When communicating, people employ idioms or acronyms and don’t care much about grammar. As a result, non-native speakers may find it more difficult to comprehend.</p><p>I recommend this video on YouTube: <a href="https://www.youtube.com/watch?v=D6_qpaSxAQc&list=PLk_6yjq2hyTZw2nNE5HAi73Mwvq-x0fap&index=2&t=28s">Understand Native English Speakers with this Advanced Listening Lesson</a>.</p><p>It clarifies why native speakers are so difficult to understand. The most common blunder is focusing on words and attempting to translate them. For example, when we put two words together, the sounds often change. As a result, we should spend more time watching, listening, and acclimating to the original English environment.</p><h3 id="3-build-up-English-mind"><a href="#3-build-up-English-mind" class="headerlink" title="3.build up English mind."></a>3.build up English mind.</h3><p>Build up English mind means thinking in English, instead of translating every words! So How can I think in English? Refer to this viedo: <a href="https://www.youtube.com/watch?v=MdUkC7Vz3rg&list=PLdz6EbLJcjJ-CeRilbye_lWwqGhmc3qPP&index=4">5 Smart Ways to Improve your Speaking Skills</a>, there are two main steps:</p><p><strong>Step 1: only use words you already  know</strong></p><p>describe an image or just surroundings around you in English. First of all, you can describe it as simple words, then some phrases, eventually a sentence. And you should do this as a daily habit.</p><p>Tips: If you don’t know the correct word, you just need to do:</p><ul><li>find a word round it</li><li>let the idea go</li></ul><p><strong>Step 2: practice with others.</strong> </p><p>Only in this way, you can know whether your English have been improved after the task of step 1.</p><h3 id="4-try-to-create-not-just-accept"><a href="#4-try-to-create-not-just-accept" class="headerlink" title="4.try to create, not just accept."></a>4.try to create, not just accept.</h3><p>When we say someone “speaks” a language fluently, we usually mean they are proficient in all four skills: listening, speaking, reading, and writing. IELTS (International English Language Testing System) assesses these four abilities.</p><p>But the most of time we accept the knowledge, and rarely express what we’ve learned. most of us perform poorly in speaking and writing. I propose that whenever we have the opportunity, such as in a presentation or an essay, we should endeavor to express ourselves in English.</p><h3 id="5-be-patient-with-yourself"><a href="#5-be-patient-with-yourself" class="headerlink" title="5.be patient with yourself."></a>5.be patient with yourself.</h3><p>Language learning is a long-term process. Nobody can gain English proficiency in a couple of months. Just be patient with yourself!</p><h2 id="Great-English-Materials"><a href="#Great-English-Materials" class="headerlink" title="Great English Materials"></a>Great English Materials</h2><p>Woo~! I eagerly want to share my favorite English materials with you guys! These make me love learning English!</p><h3 id="Video-Games"><a href="#Video-Games" class="headerlink" title="Video Games"></a>Video Games</h3><p>Language options, including subtitles and audio, would be available in most games. I strongly advise you to play games based on rich plots. I constantly pay attention to what the characters are saying in order to assist them in making the best decisions possible. When I played <em>Life Is Strange</em>, I was intrigued by the attractive plot and overwhelmed for the whole day! I’ve never read English material for such a long time. The LIS series is fantastic. LIS is my favorite. <em>Life Is Stranger:Before The Storm</em> and LIS2 are also excellent.</p><p><img src="/img/LIS.png" alt="Life Is Strange"></p><p><em>Life Is Strange</em>: It follows the exploits of 18-year old Max Caulfield, a high school senior who learns she has the power to rewind time when she saves her childhood friend, Chloe Price, from being killed.</p><p><img src="/img/LIS2.jpeg" alt="Life Is Strange2"></p><p><em>Life Is Strange2</em>: After a tragic incident, brothers Sean and Daniel Diaz run away from home. Fearing the police, and dealing with Daniel’s new telekinetic power, the boys head to Mexico. Each stop on their journey brings new friends and new challenges.</p><p><img src="/img/detriot.png" alt="Detriot: Become Human"></p><p>Detriot: Become Human depicts a fictional near-future story about a world where humans are served by lifelike androids. It has three storylines: Kara (Valorie Curry), who escapes her owner to explore her newfound sentience and protect a young girl; Connor (Bryan Dechart), whose job is to hunt down sentient androids; and Markus (Jesse Williams), who devotes himself to releasing other androids from servitude.</p><p>It has much more branches and endings than LIS. However, because there are many technical jargons, the terms are more challenging. Sometimes we must choose choices quickly within 30 seconds. It requires you a higher level of English comprehension.</p><p><img src="/img/a-plague-tale.png" alt="A Plague Tale: Innocence"></p><p><em>A Plague Tale: Innocence</em>: it features two young orphans on the run from the Inquisitio.</p><p>It’s a little bit scary with the dim atmosphere. I die a lot since I have no hand-eye coordination!</p><h3 id="TV-Series"><a href="#TV-Series" class="headerlink" title="TV Series"></a>TV Series</h3><p>I used to think that classic sitcoms were the greatest option. While I was watching <em>Friends</em>, I just couldn’t follow their speaking speed! A sitcom is a genre of comedy focused on character dialogue. Many expressions may contain other implications, making them more difficult to comprehend.</p><p>All in all, I recommend you these TV Show Genres:</p><ul><li>Documentaries, Historical Fictions</li><li>Coming-of-age story, Romantic Fictions</li><li>Thriller, Horror</li></ul><p>They have a common ground: the plots are drived by vision, not speeches.</p><p><img src="/img/stranger-things.jpg" alt="Stranger Things"></p><p><em>Stranger Things</em>: In 1980s Indiana, a group of young friends witness supernatural forces and secret government exploits. As they search for answers, the children unravel a series of extraordinary mysteries.</p><p>Recently, Stranger Things 4 is coming! I like this TV series a lot. I think it suits everybody!</p><p><img src="/img/all-of-us-are-dead.png" alt="All Of Us Are Dead"></p><p><em>All Of Us Are Dead</em>: It depicts how trapped students escape their high school which has become ground zero for a zombie virus outbreak.</p><p>It’s a Korean horror TV show, and you can choose the English audio and subtitle. I have an amazing discovery that it would be easier to understand if the main characters are teenagers or children!</p><h3 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h3><p>I believe the key to reading is your interests. So if you aren’t obsessed with classical books, just read some popular novels. Personally, I adore reading fan-fiction stories on AO3. I also enjoy male&#x2F;male romantic stories which are kind of guilty pleasure for me. (haha</p><p>I highly recommend this reading App. It helps me a lot. You can download it here: <a href="https://apps.apple.com/id/app/tingyue-for-english-learners/id645926554">App Store: tingyue for english learners</a>. TYReader is an app for improving your English skills via reading novels. It can highlight the difficult words in the left section and show their meaning in the right section.</p><p><img src="/img/tingyue-reader.png" alt="TingYue Reader"></p><h3 id="Podcasts"><a href="#Podcasts" class="headerlink" title="Podcasts"></a>Podcasts</h3><p>My ability to listen in English is inadequate. I’m trying to improve it by listening to slower-paced podcasts. The following is the list that I prefer:</p><ol><li><a href="https://open.spotify.com/show/4Ek2MUWDh5ZdiSY9UOuWXG?si=46436e57e5b44010">Spotlight English</a></li><li><a href="https://www.bbc.co.uk/learningenglish/oromo/features/6-minute-english">BBC: 6-minute English</a></li><li><a href="https://www.bbc.co.uk/learningenglish">BBC: Learning English</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Notes of Living</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
      <tag>English Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试基础知识总结（五）：DOM 和 BOM</title>
    <link href="/2022/05/12/front-end-interview-preparation-5/"/>
    <url>/2022/05/12/front-end-interview-preparation-5/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 由下面三部分组成：</p><ul><li>ECMAScript（ES5）：描述了 JS 的语法和基本对象</li><li>文档对象模型（DOM）：处理网页内容的方法和接口</li><li>浏览器对象模型（BOM）：与浏览器交互的方法和接口</li></ul><p>DOM 和 BOM 就是本章要重点介绍的内容。</p><p><img src="/img/front-end-interview-preparation/DOM-outline.png" alt="DOM 大纲"></p><h2 id="DOM-节点"><a href="#DOM-节点" class="headerlink" title="DOM 节点"></a>DOM 节点</h2><p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：</p><ul><li>整个文档是一个文档节点</li><li>每个 HTML 元素是元素节点</li><li>HTML 元素内的文本是文本节点</li><li>每个 HTML 属性是属性节点</li><li>注释是注释节点</li></ul><p>DOM 将 HTML 文档视作树结构。这种结构被称为节点树：<br><img src="/img/front-end-interview-preparation/dom-tree.png" alt="Dom 节点树"></p><h2 id="DOM-方法和属性"><a href="#DOM-方法和属性" class="headerlink" title="DOM 方法和属性"></a>DOM 方法和属性</h2><p>DOM 方法是我们可以在节点（HTML 元素）上执行的动作。<br>DOM 属性是我们可以在节点（HTML 元素）设置和修改的值。</p><p>一些常用的 HTML DOM 方法：</p><ul><li>查找节点：<code>getElementById</code>、<code>getElementsByTagName</code>、<code>getElementsByClassName</code>、<code>querySelectorAll</code></li><li>创建节点：<code>createAttribute</code>、<code>createElement</code>、<code>createTextNode</code></li><li>插入节点：<code>appendChild</code>、<code>insertBefore</code></li><li>删除节点：<code>removeChild</code></li><li>修改节点：<code>replaceChild</code></li></ul><p>一些常用的 HTML DOM 属性：</p><ul><li><code>parentNode</code> - 节点的父节点</li><li><code>childNodes</code> - 节点的子节点</li><li><code>innerHTML</code> - 节点的文本值</li><li><code>nodeValue</code> - 节点的值</li><li><code>nodeType</code> - 节点的类型（元素 1；属性 2；文本 3；注释 8；文档 9）</li><li><code>nodeName</code> - 节点的名称</li></ul><p>举个例子，添加一个元素：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>这是另一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;p&quot;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&quot;这是一个新段落。&quot;</span>);</span><br><span class="language-javascript">  para.<span class="hljs-title function_">appendChild</span>(node);</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> div1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div1&quot;</span>);</span><br><span class="language-javascript">  div1.<span class="hljs-title function_">appendChild</span>(para);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="DOM-事件体系"><a href="#DOM-事件体系" class="headerlink" title="DOM 事件体系"></a>DOM 事件体系</h2><h3 id="DOM-事件机制"><a href="#DOM-事件机制" class="headerlink" title="DOM 事件机制"></a>DOM 事件机制</h3><ul><li>DOM0：<code>el.onClick = function()&#123;&#125;</code></li><li>DOM2：<code>el.addEventListener(event-name, callback, useCapture)</code>：<code>useCapture</code>默认为 false，即在让事件在冒泡传播时执行，为 true 则代表在捕获阶段执行</li><li>DOM3：在 DOM 2 级事件的基础上添加了更多的事件类型<ul><li>UI 事件，当用户与页面上的元素交互时触发，如：load、scroll</li><li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li><li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup</li><li>…（省略更多事件），同时 DOM3 级事件也允许使用者自定义一些事件。</li></ul></li></ul><p>（DOM 级别一共可以分为四个级别：DOM0 级、DOM1 级、DOM2 级和 DOM3 级。由于 DOM 1 级中没有事件的相关内容，所以没有 DOM 1 级事件。）</p><h3 id="DOM-级别"><a href="#DOM-级别" class="headerlink" title="DOM 级别"></a>DOM 级别</h3><p>DOM 是用来访问或操作 HTML 文档、XHTML 文档、XML 文档中的节点元素。<br>现在基本上所有的浏览器都都执行了 W3C 发布的 DOM 规范，所以在浏览器上就可以用 DOM 的这些 API。</p><ul><li>DOM0：不是 W3C 规范。</li><li>DOM1：开始是 W3C 规范。专注于 HTML 文档和 XML 文档。</li><li>DOM2：对 DOM1 增加了样式表对象模型</li><li>DOM3：对 DOM2 增加了内容模型 (DTD 、Schemas) 和文档验证。</li></ul><h3 id="事件对象-Event"><a href="#事件对象-Event" class="headerlink" title="事件对象 Event"></a>事件对象 Event</h3><p>事件对象，当元素的某个事件行为被触发，不仅会把之前绑定的方法执行，还会给绑定的方法传递一个值（浏览器默认传递的）。这个值是个对象类型的值，里面存储了很多的属性和方法。</p><ul><li><code>currentTarget</code>：事件正在经过哪个元素，即事件绑定的元素</li><li><code>target</code>：触发事件的具体目标</li><li><code>preventDefault()</code>：阻止默认行为</li><li><code>stopPropagation()</code>：阻止事件冒泡</li></ul><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span>Click Me!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;outer&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;target:&#x27;</span>, event.<span class="hljs-property">target</span>.<span class="hljs-property">id</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;currentTarget:&#x27;</span>, event.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">id</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>所以，当你点击 inner 元素时，控制台将会打印：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">target: inner <span class="hljs-regexp">//</span> 实际触发事件的元素<br>currentTarget: outer <span class="hljs-regexp">//</span> 绑定事件的元素<br></code></pre></td></tr></table></figure><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><ol><li>事件捕获阶段：自上而下向目标节点传播</li><li>目标阶段</li><li>事件冒泡阶段：<ul><li>自下而上向 window 对象；</li><li>部分事件不支持冒泡：UI 事件、焦点事件、鼠标事件。</li></ul></li></ol><p><img src="/img/front-end-interview-preparation/dom-event-propagation-mechanism.png" alt="dom 事件传播机制"></p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件代理是指多个子元素的同一类型的监听逻辑，合并到父元素上通过一个监听函数来管理。主要优势是减少内存消耗。</p><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>item n<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;list&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> target = e.<span class="hljs-property">target</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (target.<span class="hljs-property">className</span> === <span class="hljs-string">&quot;item&quot;</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;the content is: &quot;</span>, target.<span class="hljs-property">innerHTML</span>);</span><br><span class="language-javascript">      <span class="hljs-comment">// ...事件处理</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面这个例子中，假设有 n（n 很大）个列表项，采取事件委托的方式，只需要在父元素上绑定监听事件函数，内存消耗小很多。</p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>创建自定义事件：<code>event = new CustomEvent(typeArg, customEventInit);</code></p><ul><li><code>typeArg</code> 事件名</li><li><code>customEventInit</code> 事件设置<ul><li><code>detail</code> 是一个与 event 相关的值，对象</li><li><code>bubbles</code> 一个布尔值，表示该事件能否冒泡。</li><li><code>cancelable</code> 一个布尔值，表示该事件是否可以取消</li></ul></li></ul><p>触发事件：<code>dispatchEvent(event)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> custom = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&quot;test_event&quot;</span>, &#123;<br>  <span class="hljs-attr">detail</span>: &#123; <span class="hljs-attr">e_name</span>: <span class="hljs-string">&quot; this is a test &quot;</span> &#125;,<br>&#125;);<br><span class="hljs-comment">// 某个dom元素监听自定义事件</span><br><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;test_event&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">detail</span>.<span class="hljs-property">e_name</span>);<br>&#125;);<br><span class="hljs-comment">// 触发自定义事件（dispatchEvent 除非事件的参数是必填项，切必须为事件对象）</span><br>div.<span class="hljs-title function_">dispatchEvent</span>(custom); <span class="hljs-comment">// this is a test</span><br></code></pre></td></tr></table></figure><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>浏览器对象模型（Browser Object Model (BOM)）尚无正式标准。</p><p>由于现代浏览器已经（几乎）实现了 JavaScript 交互性方面的相同方法和属性，因此常被认为是 BOM 的方法和属性。</p><h3 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h3><p>所有浏览器都支持 window 对象。它表示浏览器窗口。所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;header&quot;</span>);<br><span class="hljs-comment">// 与上面相同</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;header&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="Window-尺寸"><a href="#Window-尺寸" class="headerlink" title="Window 尺寸"></a>Window 尺寸</h3><p>如何获得浏览器的尺寸？</p><p>兼容的 JavaScript 方案（涵盖所有浏览器，包含 IE8 及以下版本的浏览器）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 浏览器宽度</span><br><span class="hljs-keyword">var</span> w=<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span><br>|| <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span><br>|| <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>;<br><span class="hljs-comment">// 浏览器高度</span><br><span class="hljs-keyword">var</span> h=<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span><br>|| <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span><br>|| <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientHeight</span>;<br></code></pre></td></tr></table></figure><h3 id="如何记忆各种尺寸？"><a href="#如何记忆各种尺寸？" class="headerlink" title="如何记忆各种尺寸？"></a>如何记忆各种尺寸？</h3><p>网络上广为流传的这张图可谓是眼花缭乱。原本我以为自己已经完全掌握了。可每次写代码时还总有不确定的，经常需要把下图拿出来再三确认。这一次我就好好梳理一下他们之间的关系：</p><p><img src="/img/front-end-interview-preparation/bom-offsetTop.jpg" alt="示意图"></p><p>分析上图，距离属性一共有两个维度：</p><ul><li>类型：client 、 offset、scroll</li><li>属性：<ul><li>位置：top、left</li><li>大小：width、height</li></ul></li></ul><p>两个拼在一起，就组成一个完整的距离属性。</p><table><thead><tr><th>类型</th><th>位置（top、left）</th><th>大小（width、height）</th></tr></thead><tbody><tr><td>client</td><td>border的距离</td><td>client</td></tr><tr><td>offset</td><td>元素相对于 offsetParent 边界框的距离</td><td>client(+border+滚动条)</td></tr><tr><td>scroll</td><td>border+不可见滚动区域</td><td>offset(+不可见滚动区域)</td></tr><tr><td>备注</td><td>&#x2F;</td><td>client &lt; offset &lt; scroll</td></tr></tbody></table><p>下图是更为精简的示意图：</p><p><img src="/img/front-end-interview-preparation/bom-offsetTop2.jpg" alt="示意图"></p><p>最常用的是以下两个：<br>scrollTop：距离顶部的滚动距离<br>clientHeight：可视区域的高度</p><p><img src="/img/front-end-interview-preparation/bom-scrolltop.png" alt="示意图"></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="document-ready-和-onload-的区别"><a href="#document-ready-和-onload-的区别" class="headerlink" title="document.ready 和 onload 的区别"></a>document.ready 和 onload 的区别</h3><ol><li><code>document.ready</code>：<ul><li>在 DOM 加载完成后就可以可以对 DOM 进行操作。</li><li>可以写多个.ready，可以执行多次</li><li>执行更快</li></ul></li><li><code>document.onload</code>：<ul><li>在 document 文档加载完成后就可以可以对 DOM 进行操作，document 文档包括了<strong>加载图片</strong>等其他信息。</li><li>只能执行一次</li><li>要等待图片加载，执行更慢</li></ul></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent">MDN：自定义事件</a></li><li><a href="https://www.runoob.com/htmldom/htmldom-tutorial.html">菜鸟教程：DOM</a></li><li><a href="https://www.runoob.com/js/js-window.html">菜鸟教程：BOM</a></li><li><a href="https://www.cnblogs.com/gagarinwjj/p/conflict_client_offset_scroll.html">令人头疼的 clientTop、scrollTop、offsetTop</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试基础知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front-end</tag>
      
      <tag>interview</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试基础知识总结（四）：ES6、异步</title>
    <link href="/2022/05/08/front-end-interview-preparation-4/"/>
    <url>/2022/05/08/front-end-interview-preparation-4/</url>
    
    <content type="html"><![CDATA[<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6+"></a>ES6+</h2><p>ECMAScript5，即 ES5，是 ECMAScript 的第五次修订，于 2009 年完成标准化。<br>ECMAScript6，即 ES6，是 ECMAScript 的第六次修订，于 2015 年完成，也称 ES2015。ES6 是继 ES5 之后的一次改进，相对于 ES5 更加简洁，提高了开发效率。至此之后，每一年都会出新版本，如 ES7（ES2016）、ES8（ES2017）以此类推。</p><p><img src="/img/front-end-interview-preparation/ES6-outline.png" alt="ES6+大纲"></p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。</p><p>Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> sy1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;KK&quot;</span>);<br><span class="hljs-keyword">let</span> sy2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;kk&quot;</span>);<br>sy1 === sy2;       <span class="hljs-comment">// false，相同参数 Symbol() 返回的值不相等</span><br></code></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>由于每一个 Symbol 的值都是不相等的，所以 Symbol 作为对象的属性名，可以保证属性不重名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> sy = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;key1&quot;</span>);<br><br><span class="hljs-comment">// 写法1</span><br><span class="hljs-keyword">let</span> syObject = &#123;&#125;;<br>syObject[sy] = <span class="hljs-string">&quot;kk&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(syObject);    <span class="hljs-comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span><br><br><span class="hljs-comment">// 写法2</span><br><span class="hljs-keyword">let</span> syObject = &#123;<br>  [sy]: <span class="hljs-string">&quot;kk&quot;</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(syObject);    <span class="hljs-comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span><br><br><span class="hljs-comment">// 写法3</span><br><span class="hljs-keyword">let</span> syObject = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(syObject, sy, &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&quot;kk&quot;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(syObject);   <span class="hljs-comment">// &#123;Symbol(key1): &quot;kk&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>Symbol 作为对象属性名时不能用.运算符，要用方括号。因为.运算符后面是字符串，所以取到的是字符串 sy 属性，而不是 Symbol 值 sy 属性。</p><h3 id="Map-与-Set"><a href="#Map-与-Set" class="headerlink" title="Map 与 Set"></a>Map 与 Set</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p><p>Map 与 Object 的区别：</p><ul><li>Map 的键可以是任意值，而 Object 的键只能是字符串或者 Symbol。</li><li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li><li>在性能上，Map在频繁增删键值对的场景下表现更好。（原因是Map底层是哈希表，哈希表的核心思想是使用哈希函数将键转换成数组索引，然后在该索引处存储对应的值。）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>]); <span class="hljs-comment">//default key-value</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;key2&#x27;</span>);  <span class="hljs-comment">// value2</span><br><span class="hljs-comment">// 将 Map 转 Array</span><br><span class="hljs-keyword">let</span> outArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(myMap);<br></code></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p><p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p><ul><li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以重复；</li><li>undefined 与 undefined 是恒等的，所以重复；</li><li>NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// default value</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// set(3) &#123;1, 2, 3&#125;</span><br>set.<span class="hljs-title function_">add</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// set(4) &#123;1, 2, 3, &#123;a: 1&#125;&#125;</span><br><span class="hljs-comment">// 用...操作符，将 Set 转 Array</span><br><span class="hljs-keyword">var</span> outArray = [...set];<br></code></pre></td></tr></table></figure><p>Set 可以实现数组去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]);<br>[...mySet]; <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="Reflect-与-Proxy"><a href="#Reflect-与-Proxy" class="headerlink" title="Reflect 与 Proxy"></a>Reflect 与 Proxy</h3><p>Proxy 与 Reflect 是 ES6 为了操作对象引入的 API 。</p><p>Proxy 可以对目标对象的读取、函数调用等操作进行<strong>拦截</strong>，然后进行操作处理。它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作。</p><p>Reflect 可以用于获取目标对象的行为，使用函数的方式实现了 Object 的<strong>命令式</strong>操作。它的方法与 Proxy 是对应的。</p><p><code>new Proxy(target, handler)</code></p><ul><li>target：目标对象</li><li>handler：声明代理 target 的指定行为。</li></ul><h4 id="应用：代理模式"><a href="#应用：代理模式" class="headerlink" title="应用：代理模式"></a>应用：代理模式</h4><p>代理模式 （Proxy Pattern）又称委托模式，它为目标对象创造了一个代理对象，以控制对目标对象的访问。<br>明星就相当于被代理的目标对象（Target），而经纪人就相当于代理对象（Proxy），希望找明星的人是访问者（Visitor），他们直接找不到明星，只能找明星的经纪人来进行业务商洽。主要有以下几个概念：</p><ul><li>Target： 目标对象，也是被代理对象，是具体业务的实际执行者；</li><li>Proxy： 代理对象，负责引用目标对象，以及对访问的过滤和预处理；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, propKey, receiver</span>)&#123;&#125;,<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, propKey, value, receiver</span>)&#123;&#125;<br>    <span class="hljs-attr">apply</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, ctx, args</span>)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> superStar = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;坤坤&quot;</span>,<br>  <span class="hljs-attr">act</span>: <span class="hljs-function">(<span class="hljs-params">...actions</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;坤坤表演&quot;</span>, ...actions);<br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ProxyAssistant</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;assistant&quot;</span>,<br>  <span class="hljs-attr">schedule</span>: <span class="hljs-function">(<span class="hljs-params">...actions</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(superStar.<span class="hljs-property">act</span>, &#123;<br>      <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, ctx, args</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;经纪人已通知&quot;</span> + superStar.<span class="hljs-property">name</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(target, ctx, [...actions]);<br>      &#125;,<br>    &#125;)();<br>  &#125;,<br>&#125;;<br><br><span class="hljs-title class_">ProxyAssistant</span>.<span class="hljs-title function_">schedule</span>(<span class="hljs-string">&quot;唱&quot;</span>, <span class="hljs-string">&quot;跳&quot;</span>, <span class="hljs-string">&quot;RAP&quot;</span>, <span class="hljs-string">&quot;篮球&quot;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">经纪人已通知坤坤</span><br><span class="hljs-comment">坤坤表演 唱 跳 RAP 篮球</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="应用：Vue3-的双向数据绑定"><a href="#应用：Vue3-的双向数据绑定" class="headerlink" title="应用：Vue3 的双向数据绑定"></a>应用：Vue3 的双向数据绑定</h4><p>详见这篇文章: TODO.</p><h3 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h3><h4 id="使用原型实现类"><a href="#使用原型实现类" class="headerlink" title="使用原型实现类"></a>使用原型实现类</h4><p>语法糖，本质为对原型链的二次包装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 使用class：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name ,age</span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  &#125;<br><br>  <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;肉骨头真好吃&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 使用原型：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;肉骨头真好吃&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类的用法"><a href="#类的用法" class="headerlink" title="类的用法"></a>类的用法</h4><p>类定义不会被提升，且不可重复声明。</p><ul><li>静态属性：class 本身的属性，即直接定义在类内部的属性，不需要实例化。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">static</span> a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 新提案</span><br>&#125;<br><span class="hljs-title class_">Example</span>.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 改变类的静态属性</span><br></code></pre></td></tr></table></figure></li><li>公共属性：定义在类上的属性。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span>&#123;&#125;<br><span class="hljs-title class_">Example</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li>实例属性：定义在实例对象上的属性。<br>ES6 中实例属性只能通过构造函数中的<code>this.xxx</code>来定义，ES7 提案中可以直接在类里面定义：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    a = <span class="hljs-number">2</span>; <span class="hljs-comment">// ES7，直接在类中定义属性</span><br>    <span class="hljs-title function_">constructor</span> () &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="类的访问（JS和TS）"><a href="#类的访问（JS和TS）" class="headerlink" title="类的访问（JS和TS）"></a>类的访问（JS和TS）</h4><p>在 JavaScript 中，类属性在默认情况下是<strong>公有</strong>的，但可以使用增加哈希前缀<code>#</code>的方法来定义私有类字段，这一隐秘封装的类特性由 JS 自身强制执行。</p><p>而在 TypeScript 中，可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中是允许被访问的</li></ul><p>值得注意的是：访问修饰符仅在TS层有效，编译成JS后private修饰的字段并没有转化成原生私有字段。</p><h4 id="decorator"><a href="#decorator" class="headerlink" title="decorator"></a>decorator</h4><p>decorator 是一个函数，用来修改类的行为，在代码编译时产生作用。</p><p>3 个参数：target（类的原型对象）、name（修饰的属性名）、descriptor（该属性的描述对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span>(<span class="hljs-params">target, name, descriptor</span>) &#123;<br>    <span class="hljs-comment">// descriptor对象原来的值如下</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//   value: specifiedFunction,</span><br>    <span class="hljs-comment">//   enumerable: false,</span><br>    <span class="hljs-comment">//   configurable: true,</span><br>    <span class="hljs-comment">//   writable: true</span><br>    <span class="hljs-comment">// &#125;;</span><br>    descriptor.<span class="hljs-property">writable</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> descriptor; <span class="hljs-comment">// 必须返回</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    @readonly<br>    <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 类似于</span><br><span class="hljs-comment">// Object.defineProperty(Example.prototype, &#x27;sum&#x27;, descriptor);</span><br></code></pre></td></tr></table></figure><p>修饰器执行顺序：由外向内进入，由内向外执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    @<span class="hljs-title function_">logMethod</span>(<span class="hljs-number">1</span>)<br>    @<span class="hljs-title function_">logMethod</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>)&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">logMethod</span>(<span class="hljs-params">id</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;evaluated logMethod&#x27;</span>+id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, name, desctiptor</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;excuted logMethod &#x27;</span>+id);<br>&#125;<br><span class="hljs-comment">// evaluated logMethod 1</span><br><span class="hljs-comment">// evaluated logMethod 2</span><br><span class="hljs-comment">// excuted logMethod 2</span><br><span class="hljs-comment">// excuted logMethod 1</span><br></code></pre></td></tr></table></figure><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>es5 分两种继承方式：构造函数继承和原型继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parents</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">country</span> = <span class="hljs-string">&#x27;CHINA&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Parents</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">food</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;eat &#x27;</span> + food);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// 1. 构造函数继承，把this绑定到child上</span><br>  <span class="hljs-title class_">Parents</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;little John&#x27;</span><br>&#125;<br><span class="hljs-comment">// 2. 原型继承</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parents</span>();<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br></code></pre></td></tr></table></figure><p>es6 的继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parents</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = props.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;UNKONWN&#x27;</span><br>  &#125;<br>  <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;就喜欢吃&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// extends实现类的继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parents</span> &#123;<br>  <span class="hljs-comment">// props是继承过来的属性，myAttribute是自己的属性</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props) <span class="hljs-comment">// 模拟构造函数继承，模拟ES5的Parent.apply(this, args)</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = props.<span class="hljs-property">height</span>; <span class="hljs-comment">// 自己的私有属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">weight</span> = props.<span class="hljs-property">weight</span>; <span class="hljs-comment">// 自己的私有属性</span><br>  &#125;<br>  <span class="hljs-title function_">info</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//自己私有的方法</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">weight</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">183</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">75</span> &#125;);<br>child.<span class="hljs-title function_">eat</span>(); <span class="hljs-comment">// 小明就喜欢吃</span><br>child.<span class="hljs-title function_">info</span>(); <span class="hljs-comment">// 小明 183 75</span><br></code></pre></td></tr></table></figure><h3 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h3><h4 id="AMD、CMD-与-CommonJS"><a href="#AMD、CMD-与-CommonJS" class="headerlink" title="AMD、CMD 与 CommonJS"></a>AMD、CMD 与 CommonJS</h4><p>在 ES6 之前，实现模块化的是 RequireJS(AMD)和 SeaJS(CMD)：</p><ul><li>RequireJS(AMD)：异步加载 JS 文件，通过 define()函数定义</li><li>SeaJS(CMD)：同步模块</li></ul><p>上述这俩都是基于浏览器的模块化，基于 Node 的模块化是 CommonJS 规范，是通过 module.exports 定义。</p><h4 id="ES6-模块化特点"><a href="#ES6-模块化特点" class="headerlink" title="ES6 模块化特点"></a>ES6 模块化特点</h4><p>ES6 引入模块化，设计思想是：静态加载，在编译时就确定模块的依赖关系。ES6 的模块化分为导出（export）与导入（import）两个模块。</p><ul><li>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 use strict;。</li><li>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。</li><li>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。</li><li>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。</li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="迭代器的概念和遍历过程"><a href="#迭代器的概念和遍历过程" class="headerlink" title="迭代器的概念和遍历过程"></a>迭代器的概念和遍历过程</h4><p>迭代器是一种接口，为各种不同的数据结构提供统一的遍历机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p><p>遍历过程：</p><ol><li>通过<code>Symbol.iterator</code>创建迭代器</li><li>通过 next 方法向下迭代，返回当前位置的对象，对象包含了 value 和 done 两个属性</li><li>当 done 为 true 时遍历结束</li></ol><p>下面这个例子是模拟<code>next</code>的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> it = <span class="hljs-title function_">makeIterator</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]);<br><br>it.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// &#123; value: &quot;a&quot;, done: false &#125;</span><br>it.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// &#123; value: &quot;b&quot;, done: false &#125;</span><br>it.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeIterator</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">var</span> nextIndex = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasNext</span>() ?<br>        &#123;<span class="hljs-attr">value</span>: array[nextIndex++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125; :<br>        &#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;;<br>    &#125;,<br>    <span class="hljs-attr">hasNext</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> nextIndex &lt; array.<span class="hljs-property">length</span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h4><p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性。</p><p>原生具备 Iterator 接口的数据结构有：Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">let</span> iter = arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](); <span class="hljs-comment">//得到数组的遍历器对象。</span><br>iter.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: &#x27;a&#x27;, done: false&#125;</span><br><span class="hljs-comment">// String也差不多：</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-keyword">let</span> iter2 = str[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](); <span class="hljs-comment">//得到字符串的遍历器对象。</span><br>iter2.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: &#x27;h&#x27;, done: false&#125;</span><br></code></pre></td></tr></table></figure><h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h4><p>要成为可迭代对象， 一个对象必须具有一个带 Symbol.iterator 键（key）的属性。<br>生成器函数使用 function* 语法编写，返回 <a href="#Generator">generator</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> obj = &#123;<br>  * [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;world&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br><span class="hljs-comment">// &quot;hello&quot;</span><br><span class="hljs-comment">// &quot;world&quot;</span><br><span class="hljs-comment">// ------ 转换成数组 ------</span><br>[...obj] <span class="hljs-comment">// [&#x27;hello&#x27;, &#x27;world&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p><img src="/img/front-end-interview-preparation/js-asynchrony.png" alt="异步-大纲"></p><h3 id="对异步的理解"><a href="#对异步的理解" class="headerlink" title="对异步的理解"></a>对异步的理解</h3><p>JS 是单线程的，但是却能执行异步任务，这主要是因为 JS 中存在事件循环和任务队列。简单来说，就是主线程循环往复地从”任务队列”中读取事件。</p><ul><li>主线程：JS 只有一个线程，称之为主线程。而事件循环是主线程中执行栈里的代码执行完毕之后，才开始执行的。所以，主线程中要执行的代码时间过长，会阻塞事件循环的执行，也就会阻塞异步操作的执行。只有当主线程中执行栈为空的时候（即同步代码执行完后），才会进行事件循环来观察要执行的事件回调，当事件循环检测到任务队列中有事件就取出相关回调放入执行栈中由主线程执行。</li><li>事件循环（Event Loop）：JS 会创建一个类似于<code>while (true)</code>的循环，每执行一次循环体的过程称之为<code>Tick</code>。每次 Tick 的过程就是查看是否有待处理事件，如果有则取出相关事件及回调函数放入执行栈中由主线程执行。待处理的事件会存储在一个任务队列中，也就是每次 Tick 会查看任务队列中是否有需要执行的任务。</li><li>任务队列（Task Queue）：异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如<code>onclick</code>, <code>setTimeout</code>, <code>ajax</code> 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的 3 种 webAPI，分别是 DOM Binding、timer、network 模块。<ul><li>onclick 由浏览器内核的 DOM Binding 模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中。</li><li>setTimeout 会由浏览器内核的 timer 模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中。</li><li>ajax 则会由浏览器内核的 network 模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中。</li></ul></li></ul><p>事件循环此处不作详细解释，可参考下面的大纲：<br><img src="/img/front-end-interview-preparation/event-loop.png" alt="事件循环"></p><h3 id="异步解决方案"><a href="#异步解决方案" class="headerlink" title="异步解决方案"></a>异步解决方案</h3><p>异步在实现上，依赖一些特殊的语法规则。从整体上来说，异步方案经历了如下的四个进化阶段：</p><p>回调函数 —&gt; Promise —&gt; Generator —&gt; async&#x2F;await。</p><h4 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h4><p>当回调只有一层的时候，看起来感觉没什么问题。但是一旦回调函数嵌套的层级变多了之后，代码的可读性和可维护性将面临严峻的挑战。比如当我们想发起连环网络请求时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>);<br><br><br>https.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;目标接口1&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>  https.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;目标接口2&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    https.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;目标接口3&#x27;</span>),  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>        https.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;目标接口4&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>          https.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;目标接口5&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>            .....<br>            <span class="hljs-comment">// 无尽的回调</span><br>          &#125;<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>面对无穷无尽的“回调地狱”，新的解决方案亟需开发。Promise 的出现解决了什么痛点？<br>提出链式调用，解决回调地狱的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 链式调用</span><br><span class="hljs-title function_">httpPromise</span>(url1)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">httpPromise</span>(url2);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">httpPromise</span>(url3);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">httpPromise</span>(url4);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));。<br></code></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h4><p><code>new Promise(executor)</code>接受传入的 executor（执行器）作为入参，允许你把异步任务的成功和失败分别绑定到对应的处理方法（resolve、reject）上去。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;https&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">httpPromise</span>(<span class="hljs-params">url</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>    https.<span class="hljs-title function_">get</span>(url, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(data);<br>    &#125;).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(error);<br>    &#125;);<br>  &#125;)<br>&#125;<br><br><span class="hljs-title function_">httpPromise</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;&#125;);<br></code></pre></td></tr></table></figure><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>在 Promise 实例创建后，执行器里的逻辑会立刻执行，在执行的过程中，根据异步返回的结果，决定如何使用 resolve 或 reject 来改变 Promise实例的状态。 Promise 实例有三种状态：</p><ul><li>pending 状态，表示进行中。这是 Promise 实例创建后的一个初始态。可以转变成 fulfilled 或 rejected。</li><li>fulfilled 状态，表示成功完成。这是我们在执行器中调用 resolve 后达成的状态。必须有一个 value，并且不可再转变为其他状态。</li><li>rejected 状态，表示操作失败、被拒绝。这是我们在执行器中调用 reject 后达成的状态。必须有一个 reason，并且不可再转变为其他状态。</li></ul><p>在上面这个例子里，当我们用 resolve 切换到了成功态后，Promise 的逻辑就会走到 then 中的第一个参数传入的方法里去；用 reject 切换到失败态后，Promise 的逻辑就会走到 then 中的第二个参数传入的方法里。</p><p>状态转换机制：状态是可以改变的，但它只允许被改变一次。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><code>Promise.then</code>：接受两个参数，onFulfilled 或 onRejected。可以被链式调用。<br><code>Promise.catch</code>：处理 onRejected 的情况。<br><code>Promise.all</code>：全部 promise 对象都成功触发成功，任何一个失败则失败。<br><code>Promise.race</code>：任意一个子 promise 被成功或失败后立即返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 假设已实现满足Promise/A+规范的myPromise</span><br><span class="hljs-comment">// 1.手写Promise.all</span><br><span class="hljs-comment">// 接受一个promise数组，当所有promise状态resolve后，执行resolve</span><br>myPromise.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len);<br>    <span class="hljs-keyword">let</span> done = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>      promises[i].<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        done++;<br>        res[i] = value;<br>        <span class="hljs-keyword">if</span> (done === len) <span class="hljs-title function_">resolve</span>(res);<br>      &#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(reason);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;;<br><span class="hljs-comment">// 2.手写Promise.race</span><br><span class="hljs-comment">// 接受一个promise数组，当有一个promise状态resolve后，执行resolve</span><br>myPromise.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      promises[i].<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(value);<br>      &#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(reason);<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br><span class="hljs-comment">// 3.手写Promise.catch</span><br>myPromise.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onRejected</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onRejected);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="【高阶】Promise-x2F-A-规范"><a href="#【高阶】Promise-x2F-A-规范" class="headerlink" title="【高阶】Promise&#x2F;A+规范"></a>【高阶】Promise&#x2F;A+规范</h4><p>如果你要手写一个Promise，它必须要满足Promise&#x2F;A+规范，概况如下：</p><ol><li>有三个状态：pending、fulfilled、rejected</li><li>支持链式调用：提供then方法</li><li>实现Promise决议程序：约束的就是 resolve 应该如何表现</li></ol><p>第三点有点抽象，先放置一旁。让我们先看前两点。如何实现一个Promise，能够支持前两点呢。</p><p>要想实现链式调用，要考虑以下几个重点：</p><ul><li>then方法中应该直接把 this 给 return 出去（链式调用常规操作）；</li><li>链式调用允许我们多次调用 then，多个 then 中传入的 onResolved 和 onRejected 任务，我们需要把它们维护在一个队列里；</li><li>要想办法确保 then 方法执行的时机，务必在 onResolved 队列 和 onRejected 队列批量执行前。不然队列任务批量执行的时候，任务本身都还没收集完，就乌龙了。一个比较容易想到的办法就是把批量执行这个动作包装成异步任务，这样就能确保它一定可以在同步代码之后执行了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-params">executor</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><br>  <span class="hljs-comment">// 缓存两个队列，维护 resolved 和 rejected 各自对应的处理函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedQueue</span> = [];<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedQueue</span> = [];<br><br>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br>    self.<span class="hljs-property">value</span> = value;<br>    self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      self.<span class="hljs-property">onResolvedQueue</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">resolved</span>) =&gt;</span> <span class="hljs-title function_">resolved</span>());<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br>    self.<span class="hljs-property">reason</span> = reason;<br>    self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      self.<span class="hljs-property">onRejectedQueue</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">rejected</span>) =&gt;</span> <span class="hljs-title function_">rejected</span>());<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">executor</span>(resolve, reject);<br>&#125;<br><br>myPromise.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>  <span class="hljs-comment">// 注意，onResolved 和 onRejected 必须是函数；如果不是，我们此处用一个透传来兜底</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onResolved !== <span class="hljs-string">&quot;function&quot;</span>) onResolved = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&quot;function&quot;</span>)<br>    onRejected = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> x;<br>    &#125;;<br><br>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 如果是 fulfilled 状态，执行对应的处理方法</span><br>  <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) <span class="hljs-title function_">onResolved</span>(self.<span class="hljs-property">value</span>);<br>  <span class="hljs-comment">// 若是 rejected 状态，则执行 rejected 对应方法</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;rejected&quot;</span>) <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">reason</span>);  <br>  <span class="hljs-comment">// 若是 pending 状态，则只对任务做入队处理</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;  <br>    self.<span class="hljs-property">onResolvedQueue</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title function_">onResolved</span>(self.<span class="hljs-property">value</span>)&#125;);<br>    self.<span class="hljs-property">onRejectedQueue</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">reason</span>)&#125;);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;成功!&quot;</span>);<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是第 1 个任务&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);  <span class="hljs-comment">// 这里应该输出 123</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是第 2 个任务&quot;</span>);<br>  &#125;);<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">  成功!</span><br><span class="hljs-comment">我是第 1 个任务</span><br><span class="hljs-comment">成功!</span><br><span class="hljs-comment">我是第 2 个任务</span><br><span class="hljs-comment">  */</span><br></code></pre></td></tr></table></figure><p>我们实现的myPromise，最明显的一个缺陷就是下一个then拿不到上一个then的结果。这是因为我们对then函数的处理太过粗糙，这也迫使我们重新审视上文中的第三点，如何实现Promise决议程序。</p><p>决议程序处理是以一个promise和一个value为输入的抽象操作，我们把它表示为<code>[[Resolve]](promise, x)</code>。</p><p>可以理解成：<code>promise2 = promise1.then(onFulfilled, onRejected);</code></p><p>意思是说如果onFulfilled 或 onRejected 返回了值x， 则执行 Promise 解析流程 <code>[[Resolve]](promise2, x)</code>。</p><p>只要都实现了promise&#x2F;A+标准，那么不同的Promise都可以之间相互调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-params">executor</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedQueue</span> = [];<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedQueue</span> = [];<br><br>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br>    self.<span class="hljs-property">value</span> = value;<br>    self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br>    <span class="hljs-comment">// 把异步处理放到 then 方法中的 resolveByStatus/ rejectByStatus 里面来做。</span><br>    self.<span class="hljs-property">onResolvedQueue</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">resolved</span>) =&gt;</span> <span class="hljs-title function_">resolved</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br>    self.<span class="hljs-property">reason</span> = reason;<br>    self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br>    <span class="hljs-comment">// 把异步处理放到 then 方法中的 resolveByStatus/ rejectByStatus 里面来做。</span><br>    self.<span class="hljs-property">onRejectedQueue</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">rejected</span>) =&gt;</span> <span class="hljs-title function_">rejected</span>());<br>  &#125;<br><br>  <span class="hljs-title function_">executor</span>(resolve, reject);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolutionProcedure</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// 这里 hasCalled 这个标识，是为了确保 resolve、reject 不要被重复执行</span><br>  <span class="hljs-keyword">let</span> hasCalled;<br>  <span class="hljs-keyword">if</span> (x === promise2) &#123;<br>    <span class="hljs-comment">// 决议程序规范：如果 resolve 结果和 promise2相同则reject，这是为了避免死循环</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;为避免死循环，此处抛错&quot;</span>));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 决议程序规范：如果x是一个对象或者函数，则需要额外处理下</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 首先是看它有没有 then 方法（是不是 thenable 对象）</span><br>      <span class="hljs-keyword">let</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-comment">// 如果是 thenable 对象，则将promise的then方法指向x.then。</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-comment">// 如果 then 是是一个函数，那么用x为this来调用它，第一个参数为 resolvePromise，第二个参数为rejectPromise</span><br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 如果已经被 resolve/reject 过了，那么直接 return</span><br>            <span class="hljs-keyword">if</span> (hasCalled) <span class="hljs-keyword">return</span>;<br>            hasCalled = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 进入决议程序（递归调用自身）</span><br>            <span class="hljs-title function_">resolutionProcedure</span>(promise2, y, resolve, reject);<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 这里 hascalled 用法和上面意思一样</span><br>            <span class="hljs-keyword">if</span> (hasCalled) <span class="hljs-keyword">return</span>;<br>            hasCalled = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(err);<br>          &#125;<br>        );<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果then不是function，用x为参数执行promise</span><br>        <span class="hljs-title function_">resolve</span>(x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (hasCalled) <span class="hljs-keyword">return</span>;<br>      hasCalled = <span class="hljs-literal">true</span>;<br>      <span class="hljs-title function_">reject</span>(e);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果x不是一个object或者function，用x为参数执行promise</span><br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;<br><br>myPromise.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onResolved !== <span class="hljs-string">&quot;function&quot;</span>) onResolved = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&quot;function&quot;</span>)<br>    onRejected = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">throw</span> x;<br>    &#125;;<br><br>  <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 这个变量用来存返回值 x</span><br>  <span class="hljs-keyword">let</span> x;<br><br>  <span class="hljs-comment">// resolve态的处理函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveByStatus</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 返回值赋值给 x</span><br>        x = <span class="hljs-title function_">onResolved</span>(self.<span class="hljs-property">value</span>);<br>        <span class="hljs-comment">// 进入决议程序</span><br>        <span class="hljs-title function_">resolutionProcedure</span>(promise2, x, resolve, reject);<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-comment">// 如果onResolved或者onRejected抛出异常error，则promise2必须被rejected，用error做reason</span><br>        <span class="hljs-title function_">reject</span>(e);<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// reject态的处理函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">rejectByStatus</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">// 包装成异步任务，确保决议程序在 then 后执行</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 返回值赋值给 x</span><br>        x = <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">reason</span>);<br>        <span class="hljs-comment">// 进入决议程序</span><br>        <span class="hljs-title function_">resolutionProcedure</span>(promise2, x, resolve, reject);<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-title function_">reject</span>(e);<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 注意，这里我们不能再简单粗暴 return this 了，需要 return 一个符合规范的 Promise 对象</span><br>  <span class="hljs-keyword">var</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;resolved&quot;</span>) <span class="hljs-title function_">resolveByStatus</span>(resolve, reject);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;rejected&quot;</span>) <span class="hljs-title function_">rejectByStatus</span>(resolve, reject);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<br>      self.<span class="hljs-property">onResolvedQueue</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">resolveByStatus</span>(resolve, reject); &#125;);<br>      self.<span class="hljs-property">onRejectedQueue</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">rejectByStatus</span>(resolve, reject); &#125;);<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> promise2;<br>&#125;;<br></code></pre></td></tr></table></figure><p>总而言之，手写Promise能达到第一个例子的程度就已经足够通过校招面试了。第二个例子供学习参考使用。</p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>Generator 函数可以在执行中被中断、然后等待一段时间再被我们唤醒。利用 yield 关键字，实现对异步任务的等待。</p><p>Generator 有两个区分于普通函数的部分：</p><ul><li>一是在 function 后面，函数名之前有个 * ；</li><li>函数内部有 yield 表达式。</li></ul><p>执行机制：调用遍历器对象 Iterator 的 next 方法</p><p>方法：</p><ol><li>next 方法不传入参数的时候，yield 表达式的返回值是 undefined 。当 next 传入参数的时候，该参数会作为上一步yield的返回值</li><li>return 方法返回给定值，并结束遍历 Generator 函数。</li></ol><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">sendParameter</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;start&quot;</span>);<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;2&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;one:&quot;</span> + x);<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;3&#x27;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;two:&quot;</span> + y);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;total:&quot;</span> + (x + y));<br>&#125;<br></code></pre></td></tr></table></figure><p>next传参:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> sendp1 = <span class="hljs-title function_">sendParameter</span>();<br>sendp1.<span class="hljs-title function_">next</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// start</span><br><span class="hljs-comment">// &#123;value: &quot;2&quot;, done: false&#125;</span><br>sendp1.<span class="hljs-title function_">next</span>(<span class="hljs-number">20</span>);<br><span class="hljs-comment">// one:20</span><br><span class="hljs-comment">// &#123;value: &quot;3&quot;, done: false&#125;</span><br>sendp1.<span class="hljs-title function_">next</span>(<span class="hljs-number">30</span>);<br><span class="hljs-comment">// two:30</span><br><span class="hljs-comment">// total:50</span><br><span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>return结束函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> sendp2 = <span class="hljs-title function_">sendParameter</span>();<br>sendp2.<span class="hljs-title function_">next</span>(); <br><span class="hljs-comment">// start</span><br><span class="hljs-comment">// &#123;value: &quot;2&quot;, done: false&#125;</span><br>sendp2.<span class="hljs-keyword">return</span>(<span class="hljs-number">100</span>);<br><span class="hljs-comment">// &#123;value: 100, done: true&#125;</span><br></code></pre></td></tr></table></figure><h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><p>await 关键字仅在 async function 中有效。await 返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testAwait</span> (x) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(x);<br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;);<br>&#125;<br> <br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">helloAsync</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">await</span> testAwait (<span class="hljs-string">&quot;hello world&quot;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <br>&#125;<br>helloAsync ();<br><span class="hljs-comment">// hello world</span><br></code></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for in 和 for of 的区别"></a><code>for in</code> 和 <code>for of</code> 的区别</h3><p><code>for in</code></p><ul><li>循环的是 key</li><li>推荐循环对象属性</li></ul><p><code>for of</code>（ES6 新引入的特性，修复 for in 的不足）</p><ul><li>循环的是 value</li><li>推荐遍历数组</li><li>不能循环普通的对象，需要通过和<code>Object.keys()</code>搭配使用</li></ul><h3 id="Promise串行"><a href="#Promise串行" class="headerlink" title="Promise串行"></a>Promise串行</h3><p>保证执行时串行。迭代这个任务数组，第一个任务执行完后才能执行下一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> sequence = <span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = [];<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr)&#123;<br>          <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">await</span> <span class="hljs-title function_">item</span>();<br>          result.<span class="hljs-title function_">push</span>(temp)<br>        &#125;<br>        <span class="hljs-title function_">resolve</span>(result);<br>      &#125;)()<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Promise并发调度器"><a href="#Promise并发调度器" class="headerlink" title="Promise并发调度器"></a>Promise并发调度器</h3><p>要求：<br>实现一个js限流调度器<br>实现JS限流调度器，方法add接收一个返回Promise的函数，同时执行的任务数量不能超过两个。<br>实现：</p><ol><li>判断是否有空位，无空位就阻塞住</li><li>有空位就执行任务，执行完后释放占位</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">maxNum</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">taskList</span> = []; <span class="hljs-comment">// 待执行的异步任务</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 正在执行的任务数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">concurrency</span> = concurrency;<br>  &#125;<br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">addTask</span>(<span class="hljs-params">task</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">concurrency</span>) &#123;<br>      <span class="hljs-comment">// 阻塞任务执行，等等待队列有空位</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">taskList</span>.<span class="hljs-title function_">push</span>(resolve);<br>      &#125;);<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">task</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">taskList</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 相当于resolve(), 通知等待队列的任务去执行</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">taskList</span>.<span class="hljs-title function_">shift</span>()?.();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.runoob.com/w3cnote/es6-tutorial.html">菜鸟教程：ES6 教程</a> 简单全面，适合复习</li><li><a href="https://es6.ruanyifeng.com/#README">《ECMAScript 6 入门教程》by 阮一峰</a></li><li><a href="https://www.imooc.com/read/70/article/1705">异步编程模型与异步解决方案</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端面试基础知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front-end</tag>
      
      <tag>interview</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试基础知识总结（三）：JavaScript</title>
    <link href="/2022/04/23/front-end-interview-preparation-3/"/>
    <url>/2022/04/23/front-end-interview-preparation-3/</url>
    
    <content type="html"><![CDATA[<p>JavaScript ( JS ) 是一种具有<code>头等函数</code>的轻量级，<code>解释型</code>或<code>即时编译型</code>的编程语言。虽然它是作为开发 Web 页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，例如 Node.js、 Apache CouchDB 和 Adobe Acrobat。JavaScript 是一种<code>基于原型编程</code>、<code>多范式</code>、单线程的<code>动态脚本语言</code>，并且支持面向对象、命令式和声明式（如函数式编程）风格。</p><p>开头来自<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">MDN</a>，如果有疑问可以参考下面的关键词解释：</p><ol><li>头等函数（First-class Function）：当一门编程语言的函数可以被当作变量一样用时，则称这门语言拥有头等函数。例如，在 JavaScript 中，函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。</li><li>解释型（interpreted）编程语言：会将代码一句一句直接运行，不需要像编译语言（如 C++）一样，经过编译器先行编译为机器代码，之后再运行。需要要利用解释器在运行期，动态将代码逐句解释为机器代码，或是已经预先编译为机器代码的子程序，之后再运行。</li><li>即时编译型（just-in-time compiled）：即时编译器（JIT compiler）可以理解为解释器（Interpreter）中的一个组件，对编译器进行效率优化，运行已经预先编译为机器代码的子程序。</li><li>基于原型编程（prototype-based）：原型编程是一种面向对象编程的风格。通过向其它类的实例（对象）中添加属性和方法来创建类，甚至偶尔使用空对象创建类。</li><li>多范式（multi-paradigm）：多种编程范式，常见的有命令式编程(Imperative programming)、函数式编程(Functional programming)、面向对象编程(Object-oriented programming)等。</li><li>动态脚本语言（dynamic language）：动态语言是指在运行时才确定数据类型的语言，变量使用之前不需要类型声明。脚本语言是一种解释性的语言，脚本通常以文本来保存，只要在被调用时进行解释和编译。</li></ol><p><strong>总结一下 JavaScript 的特点</strong>：</p><ul><li>解释型语言，动态脚本语言</li><li>弱类型（不需要类型声明）</li><li>单线程（异步事件通过事件循环机制处理）</li><li>跨平台（浏览器、服务器端）</li></ul><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="/img/front-end-interview-preparation/js-outline.png" alt="JavaScript核心知识点大纲"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="/img/front-end-interview-preparation/js-data-type.png" alt="数据类型-大纲"></p><p>在 JavaScript 规范中，共定义了七种数据类型：</p><ul><li>基本数据类型：Number、String、Boolean、Undefined、Null、Symbol</li><li>复杂数据类型：Object</li></ul><h4 id="1-String-类型"><a href="#1-String-类型" class="headerlink" title="1.String 类型"></a>1.String 类型</h4><p>String 类型用于表示由 n 个 16 位 <code>Unicode</code> 字符组成的字符序列，即字符串。</p><blockquote><p>Unicode 符号集采用 2 个字节（即 16 位 bit）表示一个字符，即最多可以表示 65535 个字符，这样基本上可以覆盖世界上常用的文字。实现了把所有的语言都统一到一套编码中。</p></blockquote><h5 id="1-扩展：UTF-8-和-GBK-的关系？"><a href="#1-扩展：UTF-8-和-GBK-的关系？" class="headerlink" title="1.扩展：UTF-8 和 GBK 的关系？"></a>1.扩展：UTF-8 和 GBK 的关系？</h5><blockquote><p>1.UTF-8 是 Unicode 的实现之一，定义 Unicode 符号集如何存储，是为了提高 16 位编码的使用效率。英文使用一个字节，中文使用三个字节来存储。<br>2.GBK 英文和中文都使用两个字节来存储。</p></blockquote><h5 id="2-常用操作方法（详见菜鸟教程）"><a href="#2-常用操作方法（详见菜鸟教程）" class="headerlink" title="2.常用操作方法（详见菜鸟教程）"></a>2.常用操作方法（<a href="https://www.runoob.com/jsref/jsref-obj-string.html">详见菜鸟教程</a>）</h5><ul><li>字符操作：<code>charAt(index)</code>，charCodeAt，fromCharCode</li><li>字符串提取：<code>substr(start[,length])</code>，substring ，<code>slice(start[,end])</code></li><li>位置索引：<code>indexOf(searchvalue[,start])</code> ，lastIndexOf</li><li>大小写转换：toLowerCase，toUpperCase</li><li>模式匹配：<code>match(regexp)</code>，<code>search(searchVal)</code>，<code>replace(searchVal,newVal)</code>，<code>split([separator[,limit]])</code></li><li>其他操作：<code>concat(string1, string2, ..., stringX)</code>，trim，localeCompare</li></ul><h5 id="3-基本包装类型（String、Number、Boolean-都是）"><a href="#3-基本包装类型（String、Number、Boolean-都是）" class="headerlink" title="3.基本包装类型（String、Number、Boolean 都是）"></a>3.基本包装类型（String、Number、Boolean 都是）</h5><p>为了方便的对字符串进行操作，ECMAScript 提供了一个基本包装类型：String 对象 。它是一种特殊的引用类型，JS 引擎每当读取一个字符串的时候，就会在内部创建一个对应的 String 对象，该对象提供了很多操作字符的方法，这就是为什么能对字符串调用方法的原因。</p><p>在访问字符串时，JS 引擎内部会自动完成下列处理：</p><ul><li>创建 String 类型的一个实例</li><li>在实例上调用指定的方法</li><li>销毁这个实例</li></ul><h4 id="2-Number-类型"><a href="#2-Number-类型" class="headerlink" title="2.Number 类型"></a>2.Number 类型</h4><p>双精度 IEEE754 64 位浮点数。JavaScript 能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个整数。</p><h5 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1.存储结构"></a>1.存储结构</h5><p><img src="/img/front-end-interview-preparation/number-storage-structure.png" alt="存储结构"></p><h5 id="2-为什么浮点数运算会有误差？（比如0-1-0-2-0-3）"><a href="#2-为什么浮点数运算会有误差？（比如0-1-0-2-0-3）" class="headerlink" title="2.为什么浮点数运算会有误差？（比如0.1 + 0.2 !== 0.3）"></a>2.为什么浮点数运算会有误差？（比如<code>0.1 + 0.2 !== 0.3</code>）</h5><p>事实上，这个问题并不只是在 JavaScript 中才会出现，任何使用二进制浮点数的编程语言都会有这个问题。因为十进制转换成二进制再进行运算会丢失精度，计算结果从二进制转换成十进制也会丢失精度。</p><p>解决方案：可以把小数转化成整数运算之后再变回小数来解决。</p><h5 id="3-数值转换"><a href="#3-数值转换" class="headerlink" title="3.数值转换"></a>3.数值转换</h5><p><code>Number(value)</code> 和 <code>+ value</code> 只能对字符串进行整体转换</p><p><code>parseInt(string[, radix])</code>和<code>parseFloat(string)</code> 可以对字符串进行部分转换，即只转换第一个无效字符之前的字符</p><h5 id="4-位运算"><a href="#4-位运算" class="headerlink" title="4.位运算"></a>4.位运算</h5><p>ECMAScript 中的数值以 64 位双精度浮点数存储，但位运算只能作用于整数，因此要先将 64 位的浮点数转换成 32 位的整数，然后再进行位运算，最后再将计算结果转换成 64 位浮点数存储。常见的位运算有以下几种：</p><ul><li><code>&amp;</code> 与</li><li><code>|</code> 或</li><li><code>~</code> 非</li><li><code>^</code> 异或</li><li><code>&lt;&lt;</code> 左移</li><li><code>&gt;&gt;</code> 算数右移(有符号右移) 移位的时候高位补的是其符号位，整数则补 0，负数则补 1</li><li><code>&gt;&gt;&gt;</code> 逻辑右移(无符号右移) 右移的时候高位始终补 0</li></ul><h5 id="5-四舍五入"><a href="#5-四舍五入" class="headerlink" title="5.四舍五入"></a>5.四舍五入</h5><ul><li>向上取整：<code>Math.ceil</code></li><li>向下取整：<code>Math.floor</code></li><li>四舍五入：<code>Math.round</code></li><li>固定精度（小数点后 x 位）：<code>toFixed(x)</code></li><li>固定长度：<code>toPrecision(x)</code></li><li>取整：<code>parseInt</code>、位运算</li></ul><h4 id="3-Boolean-类型"><a href="#3-Boolean-类型" class="headerlink" title="3.Boolean 类型"></a>3.Boolean 类型</h4><p>Boolean 类型只有两个字面值：true 和 false。在 JavaScript 中，所有类型的值都可以转化为与 Boolean 等价的值。</p><p>JavaScript 按照如下规则将变量转换成布尔类型：</p><ul><li>false、0、空字符串（””）、NaN、null 和 undefined 被转换为 false</li><li>所有其他值被转换为 true</li></ul><p>除了使用<code>Boolean()</code>强制类型转换，下面四种操作也返回 Boolean 值。</p><h5 id="1-关系操作符：-gt-，-gt-x3D-，-lt-，-lt-x3D"><a href="#1-关系操作符：-gt-，-gt-x3D-，-lt-，-lt-x3D" class="headerlink" title="1.关系操作符：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;"></a>1.关系操作符：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;</h5><p>当关系操作符的操作数使用了非数值时，要进行数据转换：</p><ul><li>如果两个操作数都是数值，则执行数值比较。</li><li>如果两个操作数都是字符串，则逐个比较两者对应的字符编码(charCode)，直到分出大小为止 。</li><li>如果操作数是其他基本类型，则调用 Number() 将其转化为数值，然后进行比较。</li><li>NaN 与任何值比较，均返回 false 。</li><li>如果操作数是对象，则调用对象的 valueOf 方法（如果没有 valueOf ，就调用 toString 方法），最后用得到的结果，根据前面的规则执行比较。</li></ul><h5 id="2-相等操作符：-x3D-x3D-，-x3D-，-x3D-x3D-x3D-，-x3D-x3D"><a href="#2-相等操作符：-x3D-x3D-，-x3D-，-x3D-x3D-x3D-，-x3D-x3D" class="headerlink" title="2.相等操作符： &#x3D;&#x3D;，!&#x3D;，&#x3D;&#x3D;&#x3D;，!&#x3D;&#x3D;"></a>2.相等操作符： &#x3D;&#x3D;，!&#x3D;，&#x3D;&#x3D;&#x3D;，!&#x3D;&#x3D;</h5><p>&#x3D;&#x3D;&#x3D; 和 !&#x3D;&#x3D; 操作符最大的特点是，在比较之前不转换操作数。不同类型的返回<code>false</code>，相同类型进行如下比较：</p><ul><li>String：true 仅当两个操作数具有相同顺序的相同字符时才返回。</li><li>Number：true 仅当两个操作数具有相同的值时才返回。+0 并被-0 视为相同的值。如果任一操作数为 NaN，则返回 false。</li><li>Boolean：true 仅当操作数为两个 true 或两个 false 时才返回 true。</li></ul><p>&#x3D;&#x3D; 和 !&#x3D; 操作符都会先转换操作数，然后再比较它们的相等性。在转换不同的数据类型时，需要遵循抽象相等比较算法。大致概况如下：</p><ul><li>如果两个操作数都是对象，则仅当两个操作数都引用同一个对象时才返回 true。</li><li>如果一个操作数是 null，另一个操作数是 undefined，则返回 true。</li><li>如果两个操作数是不同类型的，就会尝试在比较之前将它们转换为相同类型：<ul><li>当数字与字符串进行比较时，会尝试将字符串转换为数字值。</li><li>如果操作数之一是 Boolean，则将布尔操作数转换为 1 或 0。</li><li>如果操作数之一是对象，另一个是数字或字符串，会尝试使用对象的 valueOf()和 toString()方法将对象转换为原始值。</li></ul></li><li>如果操作数具有相同的类型，则将它们按上面&#x3D;&#x3D;&#x3D;一样的规则进行比较。</li></ul><h5 id="3-布尔操作符："><a href="#3-布尔操作符：" class="headerlink" title="3.布尔操作符：!"></a>3.布尔操作符：!</h5><p>同 <code>Boolean()</code> 的规则<br>PS：利用 ! 的取反的特点，使用 !! 可以很方便的将一个任意类型值转换为布尔值。</p><h5 id="4-条件语句：if，while，"><a href="#4-条件语句：if，while，" class="headerlink" title="4.条件语句：if，while，?"></a>4.条件语句：if，while，?</h5><p>同 <code>Boolean()</code> 的规则</p><h4 id="4-Undefined-类型"><a href="#4-Undefined-类型" class="headerlink" title="4.Undefined 类型"></a>4.Undefined 类型</h4><p>Undefined 是 Javascript 中特殊的原始数据类型，它只有一个值，即 undefined，字面意思是：未定义的值。它的语义是，希望表示一个变量最原始的状态，而非人为操作的结果。这种原始状态会在以下 4 种场景中出现：</p><ul><li>声明了一个变量，但没有赋值</li><li>访问对象上不存在的属性</li><li>函数定义了形参，但没有传递实参</li><li>使用 void 对表达式求值：ECMAScript 明确规定 void 操作符 对任何表达式求值都返回 undefined</li></ul><h4 id="5-Null-类型"><a href="#5-Null-类型" class="headerlink" title="5.Null 类型"></a>5.Null 类型</h4><p>Null 是 Javascript 中特殊的原始数据类型，它只有一个值，即 null，字面意思是：“空值”。它的语义是，希望表示一个对象被人为的重置为空对象，而非一个变量最原始的状态。</p><h4 id="6-Symbol-类型"><a href="#6-Symbol-类型" class="headerlink" title="6.Symbol 类型"></a>6.Symbol 类型</h4><p>Symbol 是 ES6 新增的一种原始数据类型，它的字面意思是：符号、标记，代表独一无二的值。</p><p>Symbol 作为基本类型，没有对应的包装类型，也就是说 Symbol 本身不是对象，而是一个函数。因此，在生成 Symbol 类型值的时候，不能使用 new 操作符 。</p><h4 id="7-Object-类型"><a href="#7-Object-类型" class="headerlink" title="7.Object 类型"></a>7.Object 类型</h4><h5 id="1-存储方式：堆存储"><a href="#1-存储方式：堆存储" class="headerlink" title="1.存储方式：堆存储"></a>1.存储方式：堆存储</h5><h5 id="2-内部特性"><a href="#2-内部特性" class="headerlink" title="2.内部特性"></a>2.内部特性</h5><p>ECMA-262 第 5 版定义了一些内部特性（attribute），用以描述对象属性（property）的各种特征。ECMA-262 定义这些特性是为了实现 JavaScript 引擎用的，因此在 JavaScript 中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如<code>[[Enumerable]]</code>。 这些内部特性可以分为两种：数据属性和访问器属性。</p><ul><li>数据属性<ul><li><code>[[Configurable]]</code>：能否通过 delete 删除属性从而重新定义属性，或者能否把属性修改为访问器属性。该默认值为 true。</li><li><code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。默认值为 true。</li><li><code>[[Writable]]</code>：能否修改属性的值。默认值为 true。</li><li><code>[[Value]]</code>：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为 undefined 。</li></ul></li><li>访问器属性<ul><li><code>[[Get]]</code>：在读取属性时调用的函数。默认值为 undefined</li><li><code>[[Set]]</code>：在写入属性时调用的函数。默认值为 undefined</li></ul></li></ul><p>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty() 方法</p><h5 id="3-对象创建方式："><a href="#3-对象创建方式：" class="headerlink" title="3.对象创建方式："></a>3.对象创建方式：</h5><ul><li>对象自变量、new Object()</li><li>工厂模式、构造函数、原型模式</li><li>组合使用构造函数模式和原型模式：使用这种模式创建对象，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存</li></ul><p>1.工厂模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cteateDog</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br></code></pre></td></tr></table></figure><p>3.原型模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myDog</span>(<span class="hljs-params"></span>)&#123;&#125;<br>myDog.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;doggy&#x27;</span>;<br>myDog.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">attack</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-keyword">var</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myDog</span>();<br></code></pre></td></tr></table></figure><h5 id="4-深拷贝-x2F-浅拷贝"><a href="#4-深拷贝-x2F-浅拷贝" class="headerlink" title="4.深拷贝&#x2F;浅拷贝"></a>4.深拷贝&#x2F;浅拷贝</h5><p>深拷贝：对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。</p><ol><li><p>使用 JSON.stringify 和 JSON.parse（但不可以拷贝函数、正则等特殊属性）</p><p>注：如果对象中含有一个函数时（很常见），就不能用这个方法进行深拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cat&quot;</span>,<br>  <span class="hljs-attr">show</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1));<br><br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;pig&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">name</span>);<br><br>obj1.<span class="hljs-title function_">show</span>();<br>obj2.<span class="hljs-title function_">show</span>(); <span class="hljs-comment">//函数被丢失</span><br></code></pre></td></tr></table></figure></li><li><p>写一个递归函数去拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//对象</span><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cat&quot;</span>,<br>  <span class="hljs-attr">show</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">//这种深拷贝函数不会丢失</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = obj;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj == <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    result = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>      result[key] =<br>        <span class="hljs-keyword">typeof</span> obj[key] == <span class="hljs-string">&quot;object&quot;</span> ? <span class="hljs-title function_">deepClone</span>(obj[key]) : obj[key];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj3 = <span class="hljs-title function_">deepClone</span>(obj1);<br><span class="hljs-comment">//输出cat</span><br>obj3.<span class="hljs-title function_">show</span>();<br></code></pre></td></tr></table></figure></li></ol><p>浅拷贝：浅拷贝就只是复制对象的引用。</p><ol><li><code>Object.assign()</code></li><li><code>arr.slice()</code>，<code>arr.concat()</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">base</span>:&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Jack&#x27;</span>&#125;&#125;;<br><span class="hljs-keyword">var</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;,obj);<br>obj2.<span class="hljs-property">base</span>.<span class="hljs-property">name</span> =<span class="hljs-string">&#x27;Tom&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">base</span>.<span class="hljs-property">name</span>,obj2.<span class="hljs-property">base</span>.<span class="hljs-property">name</span>);<span class="hljs-comment">//Tom Tom</span><br></code></pre></td></tr></table></figure><h4 id="数据类型的比较"><a href="#数据类型的比较" class="headerlink" title="数据类型的比较"></a>数据类型的比较</h4><ul><li><code>==</code> 如果数值不相等，会进行类型转换</li><li><code>===</code> 不进行类型转换</li><li><code>Object.is</code> 和<code>===</code>类似，但是对于 NaN,+0,-0 会有特殊处理<ul><li><code>Object.is(NaN, NaN)</code> true</li><li><code>Object.is(+0, -0)</code> false</li></ul></li><li><code>fun1.toString() === fun2.toString()</code> 判断两个函数相等</li></ul><h4 id="判断类型的方法"><a href="#判断类型的方法" class="headerlink" title="判断类型的方法"></a>判断类型的方法</h4><ol><li>typeof 能判断出基本数据类型(包括 es6 中的 symbol，除了 null)和 object、function<ul><li>null 被检测为 object：JS 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息。前三位都为 0 的话会被判断为 object 类型，null 的二进制表示全是 0，自然前三位也是 0，所以执行 typeof 时返回”object”，这是 JS 的历史遗留 bug。</li></ul></li><li>instanceof 检测某个实例对象的原型链上是否能找到构造函数的 prototype 属性：<code>[object] instanceof [constructor]</code><ul><li>例如<code>f instanceof Foo</code>的逻辑是：f 的<code>__proto__</code>一层一层往上，能否对应到 <code>Foo.prototype</code> 的</li><li>对于number,string,boolean这三种类型,只有通过构造函数定义才能检测出，详见下面代码。</li></ul></li><li>constructor：<code>[object].constructor === [constructor]</code><ul><li>弊端就是 constructor 所指向的的构造函数是可以被修改的</li></ul></li><li><code>Object.prototype.toString.call()</code></li><li>使用 API：如<code>Array.isArray()</code></li></ol><p>注意一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">let</span> n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">typeof</span> n; <span class="hljs-comment">// number</span><br>n <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>; <span class="hljs-comment">// false</span><br><span class="hljs-comment">// ---------------------</span><br><span class="hljs-keyword">let</span> n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">typeof</span> n2; <span class="hljs-comment">// object</span><br>n <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p><img src="/img/front-end-interview-preparation/js-prototype.png" alt="原型-大纲"></p><h4 id="原型是什么？"><a href="#原型是什么？" class="headerlink" title="原型是什么？"></a>原型是什么？</h4><p>JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象。</p><p>下面举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">const</span> f1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f1.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// 指向构造函数的原型对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 作为函数，指向原型对象</span><br></code></pre></td></tr></table></figure><p>控制台输出：</p><p><code>f1.__proto__</code>和<code>Foo.prototype</code>指向的是同一个东西，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javaScript">&#123;<br>    <span class="hljs-attr">constructor</span>: ƒ <span class="hljs-title class_">Foo</span>(), <span class="hljs-comment">// constructor指向构造函数</span><br>    [[prototype]]: <span class="hljs-title class_">Object</span> <span class="hljs-comment">// 原型链中会介绍</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/front-end-interview-preparation/prototype.png" alt="prototype"></p><p>总结：</p><ul><li>对象<ul><li><code>__proto__</code>属性，指向构造函数的原型对象</li><li><code>constructor</code>属性，指向构造函数（单从constructor属性来讲，只有prototype对象才有这个属性，而其它对象的constructor属性都是通过__proto__对象从prototype继承而来。）</li></ul></li><li>函数<ul><li>也是对象，也有<code>__proto__</code>和<code>constructor</code>属性 </li><li>除此之外还有<code>prototype</code>属性，指向原型对象（而这个原型对象的constructor属性又指向该函数）</li></ul></li></ul><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的原型对象上查找，这样的链式结构叫做原型链。</p><p><img src="/img/front-end-interview-preparation/prototype2.png" alt="原型链"></p><p>每个对象的__proto__都是指向它的构造函数的原型对象的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javaScript">f1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><p>构造函数是一个函数对象，是通过 Function 构造器产生的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-title class_">Foo</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><p>原型对象本身是一个普通对象，而普通对象的构造函数都是Object：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><p>所有的构造函数都是函数对象（包括Object），函数对象都是 Function 构造产生的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><p>Object的原型对象也有__proto__属性指向null，null是原型链的顶端：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>总而言之，原型链的尽头: </p><ol><li>对象继承自构造函数的原型对象</li><li>构造函数的原型对象本身是一个对象，继承的是Object.prototype</li><li>Object.prototype的__proto__最终指向null，null是原型链的顶端。</li></ol><h4 id="当我们new一个实例的时候，new做了什么？"><a href="#当我们new一个实例的时候，new做了什么？" class="headerlink" title="当我们new一个实例的时候，new做了什么？"></a>当我们new一个实例的时候，new做了什么？</h4><ol><li>为实例开辟内存空间</li><li>把构造函数体内的<code>this</code>指向1中开辟的内存空间</li><li>将新实例的<code>__proto__</code>这个属性指向对应构造函数的<code>prototype</code>属性</li><li>构造函数会帮你把你创建的实例return出来</li></ol><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><img src="/img/front-end-interview-preparation/js-scope.png" alt="作用域-大纲"></p><p>作用域：本质上就是程序存储和访问变量的规则。作用域就是在这个规则约束下的一个变量、函数、标识符可以被访问的区域。</p><h4 id="三种作用域"><a href="#三种作用域" class="headerlink" title="三种作用域"></a>三种作用域</h4><ul><li>全局作用域</li><li>块级作用域<ul><li>函数不是块，在语法中的block是指if&#x2F;else&#x2F;for&#x2F;while语句里2个大括号之间的部分。</li><li>let和const是块级作用域</li></ul></li><li>函数作用域<ul><li>var是全局或某个函数作用域</li></ul></li></ul><h4 id="var、let和const的区别"><a href="#var、let和const的区别" class="headerlink" title="var、let和const的区别"></a>var、let和const的区别</h4><ul><li>使用var声明的变量，函数内部作用域，能重复声明覆盖，且存在变量提升现象；</li><li>使用let声明的变量，块级作用域，不能重复声明覆盖，不存在变量提升；</li><li>使用const声明的是常量，块级作用域，在后面出现的代码中不能再修改该常量的值；</li></ul><p>使用总结：</p><ul><li>函数内部用var和let都可以，块级作用域最好用let。</li><li>在绝大多数情况下，let是可以代替var的，但是如果需要用到一些特殊功能，比如需要变量提升，需要在外部能引用内部定义的变量( 比如 try{ … }catch{ … } 语句块)，需要把变量定义为全局的属性的时候，就需要使用var。所以let不能完全替换var。</li></ul><h4 id="作用域链和两种工作模式"><a href="#作用域链和两种工作模式" class="headerlink" title="作用域链和两种工作模式"></a>作用域链和两种工作模式</h4><p>作用域链：<br>如果当前作用域中找不到变量，会探出头到外面的作用域中找。在这个查找过程中，层层递进的作用域，就形成了一条作用域链。</p><p>两种工作模型：</p><ul><li>词法作用域：在代码书写的时候完成划分，作用域链沿着它定义的位置往外延伸（JS等）</li><li>动态作用域：在代码运行时完成划分，作用域链沿着它的调用栈往外延伸（Bash、Perl）</li></ul><p>JS中词法作用域的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;xiuyan&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">changeName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;BigBear&#x27;</span>;<br>    <span class="hljs-title function_">showName</span>();<br>&#125;<br><br><span class="hljs-title function_">changeName</span>();     <span class="hljs-comment">// xiuyan</span><br></code></pre></td></tr></table></figure><h4 id="修改词法作用域"><a href="#修改词法作用域" class="headerlink" title="修改词法作用域"></a>修改词法作用域</h4><p>eval能修改词法作用域：</p><p>eval 函数的入参是一个字符串。当 eval 拿到一个字符串入参后，它会把这段字符串的内容当做一段 js 代码（不管它是不是一段 js 代码），插入自己被调用的那个位置。看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showName</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-built_in">eval</span>(str)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;aa&#x27;</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;var name = &quot;bb&quot;&#x27;</span><br><br><span class="hljs-title function_">showName</span>(str) <span class="hljs-comment">// 输出 bb</span><br></code></pre></td></tr></table></figure><p>eval (str) 这行代码被执行后作用域内 name 的值就从 ‘aa’ 变成了 ‘bb’，它成功地 “修改” 了词法作用域规则约束下在书写阶段就划分好的作用域。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><img src="/img/front-end-interview-preparation/js-closure.png" alt="闭包-大纲"></p><p>闭包是为了：保证局部变量常驻在内存中，只能通过固定的方式访问，不可以被所有人访问。</p><h4 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h4><ol><li>模拟私有变量的实现</li><li>柯里化和偏函数</li><li>防抖节流</li></ol><h4 id="应用1：模拟私有变量的实现"><a href="#应用1：模拟私有变量的实现" class="headerlink" title="应用1：模拟私有变量的实现"></a>应用1：模拟私有变量的实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> value = <span class="hljs-number">0</span>; <span class="hljs-comment">//闭包：可以保护内部值value不被非法更改</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">inc</span>) &#123;<br>      value += <span class="hljs-keyword">typeof</span> inc === <span class="hljs-string">&#x27;number&#x27;</span> ? inc : <span class="hljs-number">1</span>;<br>    &#125;,<br>    <span class="hljs-attr">getValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br>  &#125;<br>&#125;());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObject.<span class="hljs-title function_">getValue</span>()); <span class="hljs-comment">// 0</span><br>myObject.<span class="hljs-title function_">increment</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObject.<span class="hljs-title function_">getValue</span>()); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h4 id="应用2：柯里化和偏函数"><a href="#应用2：柯里化和偏函数" class="headerlink" title="应用2：柯里化和偏函数"></a>应用2：柯里化和偏函数</h4><p>柯里化：将一个 n 个参数的函数转换成 n 个单参数函数，例如把<code>fn(a,b,c)</code>变成<code>fn(a)(b)(c)</code>。</p><p>偏函数：固定你函数的某一个或几个参数，然后返回一个新的函数（这个函数用于接收剩下的参数）。偏函数应用是不强调 “单参数” 这个概念的，它的目标仅仅是把函数的入参拆解为两部分。</p><p>原有的函数形式与调用方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateName</span>(<span class="hljs-params">prefix, type, itemName</span>) &#123;<br>    <span class="hljs-keyword">return</span> prefix + type + itemName<br>&#125;<br><br><span class="hljs-comment">// 调用时一口气传入3个入参</span><br><span class="hljs-keyword">var</span> itemFullName = <span class="hljs-title function_">generateName</span>(<span class="hljs-string">&#x27;大卖网&#x27;</span>, <span class="hljs-string">&#x27;母婴&#x27;</span>, <span class="hljs-string">&#x27;奶瓶&#x27;</span>)<br></code></pre></td></tr></table></figure><p>偏函数应用改造：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateName</span>(<span class="hljs-params">prefix</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">type, itemName</span>) &#123;<br>        <span class="hljs-keyword">return</span> prefix + type + itemName<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 把3个参数分两部分传入</span><br><span class="hljs-keyword">var</span> itemFullName = <span class="hljs-title function_">generateName</span>(<span class="hljs-string">&#x27;大卖网&#x27;</span>)(<span class="hljs-string">&#x27;母婴&#x27;</span>, <span class="hljs-string">&#x27;奶瓶&#x27;</span>)<br></code></pre></td></tr></table></figure><p>柯里化应用改造：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateName</span>(<span class="hljs-params">prefix</span>) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">itemName</span>) &#123;<br>            <span class="hljs-keyword">return</span> prefix + type + itemName<br>        &#125;    <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> itemFullName = <span class="hljs-title function_">generateName</span>(<span class="hljs-string">&#x27;洗菜网&#x27;</span>)(<span class="hljs-string">&#x27;生鲜&#x27;</span>)(<span class="hljs-string">&#x27;菠菜&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="应用3：防抖节流"><a href="#应用3：防抖节流" class="headerlink" title="应用3：防抖节流"></a>应用3：防抖节流</h4><p>防抖：如果短时间内大量触发同一事件，只会执行最后一次函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>节流：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)&#123;<br>    <span class="hljs-keyword">if</span>(!timer)&#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        timer = <span class="hljs-literal">null</span>;<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      &#125;, delay)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="闭包的问题"><a href="#闭包的问题" class="headerlink" title="闭包的问题"></a>闭包的问题</h4><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，可能导致<strong>内存泄露</strong>。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><img src="/img/front-end-interview-preparation/js-this.png" alt="this-大纲"></p><p>this是当前执行上下文的一个属性。执行上下文有：全局上下文、函数上下文、Eval上下文。</p><h4 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h4><ol><li>指向调用它所在方法的那个对象（在调用时决定的）。<blockquote><p>当调用方法没有明确对象时，this 就指向全局对象。在浏览器中，指向 window；在 Node 中，指向 Global。（严格模式下，指向 undefined）</p></blockquote></li><li>箭头函数this由书写位置决定（继承执行上下文的this）。</li><li>在立即指向函数，setTimeout&#x2F;setInterval，this指向window。<blockquote><p>严格模式下，立即执行函数中this&#x3D;undefined，setTimeout和setInterval中this&#x3D;window。</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 声明位置</span><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aa&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;bb&#x27;</span><br><span class="hljs-keyword">var</span> hello = me.<span class="hljs-property">hello</span> <br><br><span class="hljs-comment">// 调用位置</span><br>me.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">// 你好，我是aa</span><br><span class="hljs-title function_">hello</span>() <span class="hljs-comment">// 你好， 我是bb</span><br></code></pre></td></tr></table></figure><p>稍微改动一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">// 声明位置</span><br><span class="hljs-keyword">var</span> me = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;me&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我是<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> you = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;you&#x27;</span>,<br>  <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> targetFunc = me.<span class="hljs-property">hello</span><br>    <span class="hljs-title function_">targetFunc</span>()<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;bb&#x27;</span><br><br><span class="hljs-comment">// 调用位置</span><br>you.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">// 你好，我是bb</span><br></code></pre></td></tr></table></figure><p>乍一看，会输出you，而不是bb。但为什么会输出bb呢？</p><p>看我们例题中的 targetFunc 这个方法，大家之所以第一直觉会认为它的 this 应该指向 you 这个对象，其实还是因为把 “声明位置” 和 “调用位置” 混淆了。我们看到虽然 targetFunc 是在 you 对象的 hello 方法里声明的，但是在调用它的时候，我们是不是没有给 targetFunc 指明任何一个对象作为它前缀？ 所以 you 对象的 this 并不会神奇地自动传入 targetFunc 里，js 引擎仍然会认为 targetFunc 是一个挂载在 window 上的方法，进而把 this 指向 window 对象。</p><p>其实原理很简单，无论调用函数包了多少层，this是看最后一层调用函数，这个函数被哪个对象调用。</p><h4 id="改变this的指向"><a href="#改变this的指向" class="headerlink" title="改变this的指向"></a>改变this的指向</h4><p>this绑定的优先级：</p><ol><li>构造函数 new 实例时绑定</li><li>显式绑定</li></ol><ul><li>仅改变：<code>bind</code></li><li>改变后直接调用：<code>call</code>、<code>apply</code><ul><li><code>fn.call(target,arg1,arg2, ...)</code></li><li><code>fn.apply(target, [arg1, ...])</code></li></ul></li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><img src="/img/front-end-interview-preparation/memory-management.png" alt="内存管理-大纲"></p><h4 id="内存的数据结构"><a href="#内存的数据结构" class="headerlink" title="内存的数据结构"></a>内存的数据结构</h4><ul><li>栈（Stack）：函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame）。所有的调用记录，就形成一个”调用栈”（call stack）。先进后出。</li><li>堆（Heap）：对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。</li><li>队列（Queue）：一个 JavaScript 运行时包含了一个待处理消息的消息队列。先进先出。</li></ul><h4 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h4><p>不管什么程序语言，内存生命周期基本是一致的：   </p><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放\归还</li></ol><p>所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 在内存中给数值变量分配空间</span><br><span class="hljs-title function_">alert</span>(a + <span class="hljs-number">100</span>);  <span class="hljs-comment">// 使用内存</span><br>a = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 使用完毕之后，释放内存空间</span><br></code></pre></td></tr></table></figure><p>JS在初始化变量时就会自动分配内存空间（1、2），那么我们主要要探究的就是如何垃圾回收（3）。</p><h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><p>垃圾回收算法的中心思想是判断内存是否<strong>不再需要</strong>。</p><ol><li><p><strong>引用计数垃圾收集</strong></p><p>这是最初级的垃圾收集算法。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//但是，对象被循环引用时内存发生泄漏</span><br><span class="hljs-comment">//下面这个例子：即使这个DOM元素从DOM树中删除了，所占用的内存空间也永远无法释放</span><br><span class="hljs-keyword">var</span> div;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//循环引用</span><br>  div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myDivElement&quot;</span>);<br>  div.<span class="hljs-property">circularReference</span> = div;<br>  <span class="hljs-comment">//占据大量内存空间</span><br>  div.<span class="hljs-property">lotsOfData</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">10000</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;*&quot;</span>); <br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>标记-清除算法</strong></p><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p><ul><li>标记阶段：在此阶段,垃圾回收器会从根对象开始遍历，标识可到达对象</li><li>清处阶段：会对堆内存从头到尾进行线性遍历，清处没被标识为可到达对象的对象</li></ul><p>循环引用将不再是问题，因为两个对象都无法获取的情况下，将会被垃圾回收器回收。从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。</p></li></ol><h4 id="JS中的堆内存和栈内存"><a href="#JS中的堆内存和栈内存" class="headerlink" title="JS中的堆内存和栈内存"></a>JS中的堆内存和栈内存</h4><p>在js引擎中对变量的存储主要有两种位置，<strong>堆内存和栈内存</strong>。</p><p><strong>栈内存</strong>主要用于存储各种<strong>基本类型的</strong>变量，包括Boolean、Number、String、Undefined、Null以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。</p><p>而堆内存主要负责像对象Object这种变量类型的存储，如下图：</p><p><img src="/img/front-end-interview-preparation/stack-and-heap.png" alt="栈内存和堆内存"></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="有几种方法可以判断是否是数组"><a href="#有几种方法可以判断是否是数组" class="headerlink" title="有几种方法可以判断是否是数组"></a>有几种方法可以判断是否是数组</h3><ol><li><p>首先 typeof 肯定不行，判读一些引用类型时，不能具体到具体哪一种类型。</p></li><li><p>使用<code>instanceof</code>或<code>constructor</code></p></li></ol>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>; <span class="hljs-comment">// true</span><br>a.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用 Array.isArray</li><li>使用 Object.prototype.toString.call()</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">MDN：JavaScript</a></li><li><a href="https://pediaa.com/what-is-the-difference-between-interpreter-and-jit-compiler/#:~:text=The%20basic%20difference%20between%20Interpreter,machine%20codes%20at%20run%20time.">What is the Difference Between Interpreter and JIT Compiler</a></li><li><a href="https://www.cnblogs.com/onepixel/p/5140944.html">细说 JavaScript 七种数据类型</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality">MDN：相等（&#x3D;&#x3D;）</a></li><li><a href="https://blog.csdn.net/cc18868876837/article/details/81211729">帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）</a></li><li><a href="https://www.imooc.com/read/70">慕课网专栏：解锁前端面试体系核心攻略</a></li><li><a href="https://www.cnblogs.com/heioray/p/9487093.html">浅析JS中的堆内存与栈内存</a></li><li><a href="https://yangbo5207.github.io/wutongluo/ji-chu-jin-jie-xi-lie/yi-3001-nei-cun-kong-jian-xiang-jie.html">yangbo5207的文章:内存空间</a></li><li><a href="https://www.jianshu.com/p/e81fcb8e7a43">由JavaScript堆栈溢出引出的函数式编程思想</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">MDN：内存管理</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">MDN：并发模型与时间循环</a></li><li>MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let">let</a>&#x2F;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var">var</a>&#x2F;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const">const</a></li><li><a href="https://blog.csdn.net/u012545017/article/details/89634012">比较var和let的区别，理解函数作用域与块级作用域</a></li><li><a href="https://www.zhihu.com/question/19554716/answer/12276503">JavaScript 里的闭包是什么？应用场景有哪些？ - tianlu</a> 简单直白的例子</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端面试基础知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front-end</tag>
      
      <tag>interview</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试基础知识总结（二）：CSS</title>
    <link href="/2022/04/18/front-end-interview-preparation-2/"/>
    <url>/2022/04/18/front-end-interview-preparation-2/</url>
    
    <content type="html"><![CDATA[<p>层叠样式表 (Cascading Style Sheets，缩写为 CSS），是一种样式表语言，用来描述 HTML 或 XML 文档的呈现。CSS 描述了在屏幕、纸质、音频等其它媒体上的元素应该如何被渲染的问题。</p><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="/img/front-end-interview-preparation/css-outline.png" alt="CSS知识点大纲"></p><h3 id="CSS-特性：值和单位"><a href="#CSS-特性：值和单位" class="headerlink" title="CSS 特性：值和单位"></a>CSS 特性：值和单位</h3><p><strong>长度</strong></p><p>px 表示的是 CSS 中的像素，是 CSS 中长度的绝对单位，是设备的相对单位。<br>设备像素比（DPR) &#x3D; 设备像素（Device pixels）数 &#x2F; CSS 像素数；</p><p>em、rem 都是 CSS 中的相对长度单位。rem 相对的是 HTML 的根元素 html 的 font-size。em 相对的是当前元素的 font-size。因为当前元素的 font-size 会继承父元素的，如果当前元素未指定 font-size，则相对的是父元素的 font-size。</p><p>vw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位。1vw &#x3D; 视口宽度均分成 100 份中 1 份的长度。</p><h3 id="CSS-特性：CSS动画"><a href="#CSS-特性：CSS动画" class="headerlink" title="CSS 特性：CSS动画"></a>CSS 特性：CSS动画</h3><h4 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h4><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">animation</span>: name duration timing-function delay iteration-count direction;<br></code></pre></td></tr></table></figure><p>animation-name | 规定需要绑定到选择器的 keyframe 名称。</p><h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transition</span>: property duration timing-function delay;<br></code></pre></td></tr></table></figure><p>transition-property | 规定设置过渡效果的 CSS 属性的名称。</p><h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h4><p>你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p><h4 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h4><ol><li><p>使用requestAnimationFrame替换setTimeout&#x2F;setInterval</p><p>requestAnimationFrame是在屏幕刷新后执行，避免掉帧。</p></li><li><p>CSS硬件加速</p><p>动画卡顿是在移动web开发时经常遇到的问题，解决这个问题一般会用到css3硬件加速。简单来说：通过GPU进行渲染，解放CPU。</p><p><code>transform</code>、<code>opacity</code>、<code>filter</code>可以触发</p></li><li><p>针对性优化：特定平台禁用动画</p><p><code>this.userClient = /Android/i.test(navigator.userAgent);</code></p></li><li><p>使用<code>will-change</code>通知浏览器你打算更改元素的属性，浏览器会在你进行更改之前做最合适的优化。</p></li><li><p>尽可能地使用基于css的动画，不仅仅更快，也不会被大量的js计算所阻塞。</p></li></ol><h3 id="布局：文档流"><a href="#布局：文档流" class="headerlink" title="布局：文档流"></a>布局：文档流</h3><p>文档流：会把内容按照从左到右、从上到下的顺序进行排列显示。</p><p>文档一旦脱流，计算其父节点高度时不会将其高度纳入，脱流节点不占据空间。如何脱离文档流？</p><ul><li>浮动元素</li><li>绝对定位</li></ul><h3 id="布局：块级上下文"><a href="#布局：块级上下文" class="headerlink" title="布局：块级上下文"></a>布局：块级上下文</h3><p>块格式化上下文（Block Formatting Context，BFC）是一个作用范围，独立的容器。</p><ul><li>容器里面的元素不会在布局上影响到外面的元素。</li><li>BFC 的区域不会与 float 盒子重叠。</li><li>内部的盒子会在垂直方向，一个接一个地放置</li><li>计算 BFC 的高度时，浮动元素也参与计算</li><li>属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠</li></ul><h4 id="如何创建-BFC"><a href="#如何创建-BFC" class="headerlink" title="如何创建 BFC?"></a>如何创建 BFC?</h4><p>常见的有：</p><ul><li>根元素：html</li><li>浮动元素：float 属性不为 none</li><li>绝对定位元素：position 为 absolute 或 fixed</li><li>overflow 不为 visible 的元素</li><li>display 值为 flow-root 的元素</li><li>定义成块级的非块级元素：display: inline-block&#x2F;table-cell&#x2F;table-caption&#x2F;flex&#x2F;inline-flex&#x2F;grid&#x2F;inline-grid</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol><li>自适应两栏布局：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。</li><li>清除内部浮动：浮动造成的问题就是父元素高度坍塌，所以清除浮动需要解决的问题就是让父元素的高度恢复正常。而用 BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。</li><li>防止垂直 margin 合并：BFC 渲染原理之一：同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个 BFC 中即可阻止垂直 margin 合并。</li></ol><h4 id="格式化上下文的分类"><a href="#格式化上下文的分类" class="headerlink" title="格式化上下文的分类"></a>格式化上下文的分类</h4><ul><li>BFC (Block Formatting Context) 块级格式化上下文；</li><li>IFC (Inline Formatting Context) 行内格式化上下文；</li><li>FFC (Flex Formatting Context) 弹性格式化上下文；</li><li>GFC (Grid Formatting Context) 格栅格式化上下文；</li></ul><h3 id="布局：层叠上下文"><a href="#布局：层叠上下文" class="headerlink" title="布局：层叠上下文"></a>布局：层叠上下文</h3><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context">MDN-层叠上下文</a></p><p>我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。</p><h4 id="如何比较两个元素的层叠等级？"><a href="#如何比较两个元素的层叠等级？" class="headerlink" title="如何比较两个元素的层叠等级？"></a>如何比较两个元素的层叠等级？</h4><ol><li>先比较两个元素分别所处的层叠上下文的等级</li><li>如果在同一个层叠上下文中，再比较层叠顺序（见下图）</li><li>如果两个元素都在同一个层叠上下文，且层叠顺序相同，则在 HTML 中定义越后面的层叠等级越高。</li></ol><p><img src="/img/front-end-interview-preparation/the-stacking-context-1.png" alt="同一个层叠上下文中的层叠顺序"></p><h3 id="布局：position-属性"><a href="#布局：position-属性" class="headerlink" title="布局：position 属性"></a>布局：position 属性</h3><p>CSS<code>position</code>属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。</p><ul><li><code>static</code>：默认值。元素在文档常规流中当前的布局位置。</li><li><code>relative</code>：⽣成相对定位的元素，相对于其正常位置进⾏定位。</li><li><code>absolute</code>：⽣成绝对定位的元素，相对于<strong>static 定位以外的第一个父元素</strong>进行定位。</li><li><code>fixed</code>：⽣成绝对定位的元素，相对于浏览器窗⼝进⾏定位。</li><li><code>sticky</code>：粘性定位，基于浏览器的滚动位置变化，是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</li></ul><h3 id="常见需求：1px-边框问题"><a href="#常见需求：1px-边框问题" class="headerlink" title="常见需求：1px 边框问题"></a>常见需求：1px 边框问题</h3><p>1px 问题指的是：在一些 Retina 屏幕的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。是因为：<code>设备的物理像素 = window.devicePixelRatio * CSS像素</code>。</p><p>解决方案（以<code>devicePixelRatio = 2</code>为例）：</p><ul><li>伪元素 + transform 实现：利用伪元素 :after 重做 border ，并用 transform 的 scale 缩小一半</li><li>viewport 缩放：修改<code>initial-scale</code>等属性<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span></span><br><span class="hljs-tag">  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="常见需求：清除浮动"><a href="#常见需求：清除浮动" class="headerlink" title="常见需求：清除浮动"></a>常见需求：清除浮动</h3><p>为什么要清除浮动？</p><p>因为浮动元素会脱离正常的文档流，并不会占据文档流的位置，易造成<strong>父元素高度坍塌</strong>的问题。</p><p>解决方案：</p><ol><li>父级 div 定义 height</li><li>BFC 清除浮动：因为计算 BFC 高度的时候浮动子元素的高度也将计算在内，所以创建 BFC 即可（如父级 div 定义<code>overflow: hidden</code>）</li><li>父级 div 定义伪元素:after 和 zoom<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For IE 6/7 only</span><br><span class="hljs-comment"> * Include this rule to trigger hasLayout and contain floats.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-selector-class">.clearfix</span> &#123;<br>  *zoom: <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="常见需求：布局方案"><a href="#常见需求：布局方案" class="headerlink" title="常见需求：布局方案"></a>常见需求：布局方案</h3><p>参考：<a href="https://juejin.cn/post/6941206439624966152#heading-43">1.5 万字 CSS 基础拾遗（核心知识、常见需求）</a></p><h4 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h4><p>让元素在父元素中呈现出水平垂直居中的形态，无非就 3 种情况：</p><ol><li>单行的文本、inline 或者 inline-block 元素；<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.single-line</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>固定宽高的块级盒子<ul><li>绝对定位（absolute + calc）<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - <span class="hljs-number">50px</span>);<br>  <span class="hljs-attribute">left</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - <span class="hljs-number">50px</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>不固定宽高的块级盒子<ul><li>绝对定位（absolute + transform）<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>flex 布局<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>table-cell 布局<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>实现垂直居中：</p><ul><li>视口的垂直居中可以使用 margin:50vh auto</li><li>使用绝对定位 top:50% 加载负 margin</li><li>绝对定位 top 加上 calc</li><li>绝对定位 加上 transform</li><li>使用 flex 布局</li></ul><p>实现水平居中：</p><ul><li>父元素使用 text-align:center，子元素为 inline&#x2F;inline-block</li><li>使用 margin:0 auto（对于块级元素，要定义宽度）</li><li>使用绝对定位</li></ul><h4 id="两栏布局：一边给定宽度，一边自适应"><a href="#两栏布局：一边给定宽度，一边自适应" class="headerlink" title="两栏布局：一边给定宽度，一边自适应"></a>两栏布局：一边给定宽度，一边自适应</h4><ol><li>使用 float，左栏 float:right 右栏 overflow: hidden;（BFC）</li><li>使用定位布局，左栏 position:absolute，右栏 margin-left:200px</li><li>使用 flex 布局，容器 display:flex，左栏定宽，右栏 flex:1</li><li>使用 grid 布局，容器 display:grid，grid-template-columns: 200px auto;</li></ol><h4 id="三栏布局：两边顶宽，中间自适应"><a href="#三栏布局：两边顶宽，中间自适应" class="headerlink" title="三栏布局：两边顶宽，中间自适应"></a>三栏布局：两边顶宽，中间自适应</h4><ol><li>圣杯布局<br>  为了中间div内容不被遮挡，将父元素设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。可参考：<a href="https://codepen.io/canyzhou/pen/zYpbjXE?editors=1100">demo</a><br>  <img src="/img/front-end-interview-preparation/3-cols-layout-1.png" alt="圣杯布局"></li><li>双飞翼布局<br>  为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在中间div里用margin-left和margin-right为左右两栏div留出位置。可参考：<a href="https://codepen.io/canyzhou/pen/mdpoKdY">demo</a><br>  <img src="/img/front-end-interview-preparation/3-cols-layout-2.png" alt="双飞翼布局"></li><li>float布局（BFC）</li><li>flex布局</li><li>grid布局  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.layout</span>&#123;<br>   <span class="hljs-attribute">display</span>: grid;<br>   <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> auto <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h4><p>对于父元素：</p><ul><li><code>flex-direction</code> 主轴方向</li><li><code>flex-wrap</code> 排不下是否换行</li><li><code>flex-flow</code> flex-direction 和 flex-wrap 的简写形式</li><li><code>justify-content</code> 项目在主轴上的对齐方式<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between |space-around; <br></code></pre></td></tr></table></figure></li><li><code>align-items</code> 项目在交叉轴上如何对齐<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;<br></code></pre></td></tr></table></figure></li><li><code>align-content</code> 多根轴线的对齐方式</li></ul><p>对于子元素：</p><ul><li><code>flex-grow</code> 定义项目的放大比例，默认值为0，不放大</li><li><code>flex-shrink</code> 定义了项目的缩小比例，默认为1，空间不足将缩小</li><li><code>flex-basis</code> 分配多余空间之前，项目占据的主轴空间，默认为auto，即项目的本来大小</li><li><code>flex</code> flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。后面两个属性可选</li><li><code>align-self</code> 允许单个项目有与其他项目不一样的对齐方式</li><li><code>order</code> 项目的排列顺序。数值越小，排列越靠前</li></ul><h4 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h4><p>Responsive design，意在实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。</p><p>方案：</p><ol><li>媒体查询 + rem （动态控制根元素font-size的大小）</li><li>flex弹性布局</li><li>百分比布局，如vw&#x2F;vh</li></ol><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="margin-0-auto-中auto的取值"><a href="#margin-0-auto-中auto的取值" class="headerlink" title="margin: 0 auto;中auto的取值"></a><code>margin: 0 auto;</code>中auto的取值</h3><p>想要水平居中某个元素时,可以设置<code>margin: 0 auto;</code></p><p>auto 的取值 ：</p><ul><li>当父元素的布局方式为 static&#x2F;relative 且<strong>宽高已知</strong>时：父元素剩余空间的宽度</li><li>当父元素的布局方式为 absolute&#x2F;fixed 或者 float&#x2F;inline 或者宽高未知时：0</li></ul><h3 id="CSS中的百分比是相对什么？"><a href="#CSS中的百分比是相对什么？" class="headerlink" title="CSS中的百分比是相对什么？"></a>CSS中的百分比是相对什么？</h3><p>元素百分比的计算值是通过元素的包含块（containing block）计算得到的。</p><blockquote><p>元素的尺寸及位置，常常会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值 （比如 position 被设置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。<br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block">MDN: containing block</a></p></blockquote><ul><li>要计算<code>height</code>, <code>top</code> 及 <code>bottom</code> 中的百分值，是通过包含块的<code>height</code>的值。如果包含块的 height 值会根据它的内容变化，而且包含块的 position 属性的值被赋予 relative 或 static ，那么，这些值的计算值为<code>auto</code>。</li><li>要计算<code>width</code>, <code>left</code>, <code>right</code>, <code>padding</code>, <code>margin</code> 这些属性由包含块的<code>width</code>属性的值来计算它的百分值。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.cn/post/6941206439624966152#heading-0">1.5 万字 CSS 基础拾遗（核心知识、常见需求）</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps">MDN - 学习 CSS 第一步</a></li></ol><p>TODO:</p><ul><li><input checked="" disabled="" type="checkbox"> 圣杯和双飞翼布局写个demo</li><li><input disabled="" type="checkbox"> CSS动画的demo</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试基础知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front-end</tag>
      
      <tag>interview</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试基础知识总结（一）：大纲、HTML</title>
    <link href="/2022/04/14/front-end-interview-preparation-1/"/>
    <url>/2022/04/14/front-end-interview-preparation-1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我在去年春天为了暑期实习做了很多准备，也参加了近30场技术面试，最终拿到了大厂的offer。之前准备的面经知识总结有些零碎，所以想重新整理一下，一方面自己在整理过程中可以重温知识点，另一方面如果未来被“毕业”了也可以掏出来复习。</p><h2 id="前端知识大纲"><a href="#前端知识大纲" class="headerlink" title="前端知识大纲"></a>前端知识大纲</h2><p>下图是我总结的面试常考知识点的大纲：</p><p><img src="/img/front-end-interview-preparation/fe-outline.png"></p><p>我把前端面试中常考核的内容分成七个模块：基础、框架、前端工程化、浏览器原理、计算机网络、算法与数据结构、服务器基础。其中基础固然是最重要的，HTML、CSS、JavaScript、Dom是每一个前端er必须掌握好的内容。CSS常考核的知识点都在上面的思维导图上来，HTML考核的频次较少。JavaScript会考核的较为细致，除了会问一些基础概念，也会出手写题或者让你看代码说输出结果。同时ES6（即ES2015）从2015年后每年都会出新版本，像Promise、Class类在实际生产中非常常用，也经常在面试中考核。</p><p>根据你简历上的技术栈，Vue和React框架一般择其一考察。基本面试官都会问你更熟悉哪个技术栈再考察该框架的知识点，所以尤其要深入准备一个框架，除了吃透API、生命周期的基本概念，还要去了解底层原理，如果能了解该框架最新的发展趋势就更好了。同时还需要了解框架通识，比如MVVM和MVC的区别，Virtual Dom是什么，Vue和React的区别和各自优势等。</p><p>计算机网络、数据结构和算法这俩算是计算机科班人都会的基础知识。当然前端也会考核，但不会那么难。考核的趋势是一年比一年难，所以还是要做好心理准备。算法题上LeetCode刷上100~200道题绝对够用了，同时还需要掌握手写JS题（手写Promise等）。至于设计模式和编程范式不一定会考核，但最好也有所了解。在计算机网络领域，前端面试就喜欢问跨域问题，一定要深入、再深入的准备。Web安全、HTTPS、TCPIP之类的都是老生常谈了。</p><p>浏览器原理主要考核浏览器渲染方面。经典面试题“输入一个url到地址栏，浏览器经历了哪些变化”出现频率之高令人咂舌，默默吐槽一下感觉每个公司面试都会问到！在前端工程化领域，面试官经常会考核webpack和性能优化，也会问你对前端工程化的理解，会对前端发展趋势的看法。服务器基础的知识属于加分项，会最好，不会问题也不大。主要NodeJs太常用了，不了解说不过去。</p><p>除了上述知识点，项目经历的考核也占据了面试的半壁江山。一般而言，如果你的项目经历越出众，面试官越会对你的项目更感兴趣，从而提问更长的时间。这时候你要做的就是好好复盘整个项目，并准备好与该项目技术栈相关的发散性的各方面知识点。正所谓，不需要面面俱到，但要深入一二。</p><h1 id="基础：HTML"><a href="#基础：HTML" class="headerlink" title="基础：HTML"></a>基础：HTML</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="/img/front-end-interview-preparation/HTML-outline.png"></p><h3 id="HTML是什么？"><a href="#HTML是什么？" class="headerlink" title="HTML是什么？"></a>HTML是什么？</h3><p>超文本标记语言 (英语：Hypertext Markup Language，简称：HTML ) 是一种用来结构化 Web 网页及其内容的标记语言。</p><h3 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h3><ul><li>HTML4：标签可以不结束</li><li>HTML5：新增内容</li><li>XHTML<ul><li>目的是传输和存储数据，而不是描述数据</li><li>比HTML更严格：标签必须结束，属性必须带引号，属性必须有值，标签属性必须有值</li></ul></li></ul><h3 id="HTML元素分类"><a href="#HTML元素分类" class="headerlink" title="HTML元素分类"></a>HTML元素分类</h3><ul><li>块级元素block（方块形状，占据一整行）：div ul ol li dl dt dd h1~h5 p</li><li>行内元素inline(一行中的某个位置)：a b span img input select strong</li><li>inline-block(行内，有宽高属性)：selection</li><li>空元素: br、meta、hr、link、input、img</li></ul><p>嵌套关系：</p><ul><li>块级元素可以包含行内元素</li><li>块级元素不一定能包含块级元素(p标签不能包含div标签)</li><li>行内元素“一般”不能包含块级元素（a包含div是可以的）</li></ul><h3 id="HTML5新增内容"><a href="#HTML5新增内容" class="headerlink" title="HTML5新增内容"></a>HTML5新增内容</h3><ol><li>更好的语义化标签<blockquote><p><code>&lt;section&gt;</code>用于对网站和页面内容分块，划分单独的模块区域<br><code>&lt;article&gt;</code>独立的文章展示<br><code>&lt;aside&gt;</code>页面中的附属侧边信息<br><code>&lt;header&gt;</code>定义页面或内容的头部区域<br><code>&lt;footer&gt;</code>定义页面或内容的底部区域<br><code>&lt;nav&gt;</code>定义页面导航<br><code>&lt;figure&gt;</code>表示一个独立的内容</p></blockquote></li></ol><ul><li>作用：1.利于SEO 2.增强代码可读性</li></ul><ol start="2"><li>Web Workers：运行在后台的 JavaScript，实现多线程</li><li>应用缓存：通过创建manifest 文件，可以轻松地创建 web 应用的离线版本</li><li>requestAnimationFrame：保证回调函数在屏幕每一次的刷新建个中只执行一次，动画不掉帧</li><li>增加了canvas，拖放api，地理定位Geolocatio…</li></ol><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Doctype作⽤-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作⽤-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作⽤? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作⽤? 严格模式与混杂模式如何区分？它们有何意义?</h3><p><code>&lt;!DOCTYPE&gt;</code>声明位于位于HTML文档中的第一行，处于<code>&lt;html&gt;</code>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p><ul><li><p>严格模式：排版和JS运作模式都是以该浏览器支持的最高标准运行。</p></li><li><p>混杂模式(兼容模式)：页面以宽松的向后兼容的方式显示, 模拟老式浏览器的行为以防止站点无法工作。</p></li></ul><h3 id="HTML全局属性-global-attribute-有哪些？"><a href="#HTML全局属性-global-attribute-有哪些？" class="headerlink" title="HTML全局属性(global attribute)有哪些？"></a>HTML全局属性(global attribute)有哪些？</h3><p>全局属性可用于任何 HTML 元素:</p><ul><li><code>class</code>：为元素设置类标识</li><li><code>id</code> id标识符</li><li><code>draggable</code>: 是否可拖拽</li><li><code>data-*</code>： 为元素增加⾃定义属性</li><li><code>style</code> 行内元素</li></ul><h3 id="为什么script标签在body底部，style标签在head上？"><a href="#为什么script标签在body底部，style标签在head上？" class="headerlink" title="为什么script标签在body底部，style标签在head上？"></a>为什么script标签在body底部，style标签在head上？</h3><p>浏览器解析HTML文档是自上而下的，遇到默认的<code>&lt;script&gt;</code>标签，会导致浏览器必须先加载并执行脚本，之后才能继续解析。对于那些需要很多JavaScript代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。</p><p>同理浏览器解析HTML文档是自上而下的，这样<code>&lt;style&gt;</code>标签里的样式就会作用到body里的元素上。如果<code>&lt;style&gt;</code>标签写在<code>&lt;body&gt;</code>标签下面，在这之前的元素的样式就不会生效，会导致页面结构出来了，而CSS还没开始渲染。</p><p><code>&lt;style&gt;</code>标签还有两个属性：</p><p><code>async</code>属性:</p><ol><li>对于普通脚本，如果存在 async 属性，那么普通脚本会被并行请求，<strong>并尽快解析和执行</strong>。</li><li>对于模块脚本，如果存在 async 属性，那么脚本及其所有依赖都会在延缓队列中执行，因此它们会被并行请求，并尽快解析和执行。</li></ol><p><code>defer</code>属性:</p><ol><li>并行请求，将在文档完成解析后，<strong>触发 DOMContentLoaded 事件前执行</strong>。</li><li>对模块脚本没有作用 —— 他们默认 defer</li></ol><p><em>TBC.</em></p>]]></content>
    
    
    <categories>
      
      <category>前端面试基础知识总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>front-end</tag>
      
      <tag>interview</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
